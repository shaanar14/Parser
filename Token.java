/*
    Project 1b
    Author: Shaan Arora, C3236359
    Token Class
        Contains all functionality for the tokens generated by the lexical scanner
*/

public class Token
{
    //Member variables for a Token object
    //tokenID to store the ID of the Token object
    //lexeme for the lexeme associated with integer literals,float/real literals,string literals, identifiers and undefined
    //lineNo for which line the Token object is located at
    // colNo for which column the Token object starts
    private Tokens tokenID;
    private String lexeme;
    private int lineNo;
    private int colNo;

    //static because we want TPRINT for all object instances of Token
    //final because TPRINT is used for output formatting and we do not want it to change
    private static final String[] TPRINT = {
            "T_EOF ",
            "TCD20 ",	"TCONS ",	"TTYPS ",	"TTTIS ",	"TARRS ",	"TMAIN ",
            "TBEGN ",	"TTEND ",	"TARAY ",	"TTTOF ",	"TFUNC ",	"TVOID ",
            "TCNST ",	"TINTG ",	"TREAL ",	"TBOOL ",	"TTFOR ",	"TREPT ",
            "TUNTL ",	"TIFTH ",	"TELSE ",	"TINPT ",	"TPRIN ",	"TPRLN ",
            "TRETN ",	"TNOTT ",	"TTAND ",	"TTTOR ",	"TTXOR ",	"TTRUE ",
            "TFALS ",	"TCOMA ",	"TLBRK ",	"TRBRK ",	"TLPAR ",	"TRPAR ",
            "TEQUL ",	"TPLUS ",	"TMINS ",	"TSTAR ",	"TDIVD ",	"TPERC ",
            "TCART ",	"TLESS ",	"TGRTR ",	"TCOLN ",	"TLEQL ",	"TGEQL ",
            "TNEQL ",	"TEQEQ ",	"TPLEQ ",	"TMNEQ ",	"TSTEQ ",	"TDVEQ ",
            "TSEMI ",	"TDOTT ",
            "TIDEN ",	"TILIT ",	"TFLIT ",	"TSTRG ",	"TUNDF "};

    //Default Constructor
    //Preconditions: none
    //Postconditions: Private member variables set to default values, using end of file token as default
    public Token()
    {
        this.tokenID = null;
        this.lexeme = "";
        this.lineNo = 0;
        this.colNo = 0;
    }

    //Preconditions: None
    //Postconditions: For the current Token object, assign the values of the parameters to the private member variables
    public Token(String lex, int line, int col)
    {
        this.tokenID = null;
        this.lexeme = lex;
        this.lineNo = line;
        this.colNo = col;
    }


    //Preconditions: i >= 0
    //Postconditions: For the current Token object, assign the values of the parameters to the private member variables,
    public Token(Tokens t, String lex, int lineNo, int colNo)
    {
        this.tokenID = t;
        this.lexeme = lex;
        this.lineNo = lineNo;
        this.colNo = colNo;
    }

    //Setters

    //Preconditions:  i >= 0
    //Postconditions: tokenID of the current Token object is assigned the value of i
    public void setTokenID(Tokens t) {this.tokenID = t;}

    //Preconditions:  None
    //Postconditions: lexeme of the current Token object is assigned the value of lex
    public void setLexeme(String lex) {this.lexeme = lex;}

    //Preconditions: line is >= 0
    //Postconditions: lineNo of the current Token  object is assigned the value of line
    public void setLineNo(int line) {this.lineNo = line;}

    //Preconditions:  col >= 0
    //Postconditions: colNo of the current Token object is assigned the value of col
    public void setColNo(int col) {this.colNo = col;}

    //Getters

    //Preconditions: tokenID is not null
    //Postcondition: Returns the ID number value of the current Token object
    public Tokens getTokenID() {return this.tokenID;}

    //Preconditions: None
    //Postconditions: Return the lexeme value for the current Token object
    public String getLexeme() {return this.lexeme;}

    //Preconditions: None
    //Postconditions: Return the value of lineNo for the current Token object
    public int getLineNo() {return this.lineNo;}

    //Preconditions:  None
    //Postconditions: Return the value of colNo for the current Token object
    public int getColNo() {return  this.colNo;}

    //Helper function for toString()
    //Preconditions:  None
    //Postconditions: Returns the String from TPRINT that matches the token ID for the current Token object
    private String outputMatch()
    {
        for(String s : TPRINT)
        {
            //s.trim() will remove all whitespaces from any of the strings in TPRINT
            //if we do not trim/remove whitespaces then we will never return a string from TPRINT
            //Return the original string from TPRINT because we want to include the white space
            if(this.getTokenID().toString().equals(s.trim())) {return s;}
        }
        //if the above fails then return an empty string
        return "";
    }

    //Override to neatly format and output a Token object
    //Preconditions:  Current token object (this) is != null
    //Postconditions: Returns a formatted String depending on what the ID of the token is, used for output
    @Override
    public String toString()
    {
        String output = outputMatch();
        //This is to fix indexing and out of bounds issues since 55 doesnt exist in the enum
        //output = this.getTokenID() >= 56 ? TPRINT[this.getTokenID() - 1] : TPRINT[this.getTokenID()];
        //if the tokenID is that for an indentifier, integer literal, real literal or float literal print its lexeme
        //as per assignment spec the second field is rounded up in length to the next multiple of 6 characters
        if(this.getTokenID() == Tokens.TIDEN || this.getTokenID() == Tokens.TILIT || this.getTokenID() == Tokens.TFLIT)
        {
            //n will be the length of the lexeme
            double n = this.getLexeme().length();
            //add padding if the size of the lexeme not 6
            if(n < 6)
            {
                while (this.getLexeme().length() != 5)
                {
                    String lex = this.getLexeme() + " ";
                    this.setLexeme(lex);
                }
                //update n if padding was added above
                n = this.getLexeme().length();
            }
            else if (n % 6 != 0)
            {
                //ceiling function of the length of the lexeme divided by 6 and then times that value by 6
                //e.g. if n = 13 then this will be rounded up ot 18 which is the next multiple of 6 characters
                n = ((Math.ceil(n/6)) * 6);
                while(this.getLexeme().length() != (n -1))
                {
                    String lex = this.getLexeme() + " ";
                    this.setLexeme(lex);
                }
            }
            n = this.getLexeme().length();
            //if the token is a string literal token add back the quotation marks
            output += String.format("%." + (int) n + "s", this.getLexeme()) + " ";

        }
        else if(this.getTokenID() == Tokens.TSTRG)
        {
            output += String.format("\"%s\" ", this.getLexeme());
        }
        //if the token is TUNDF, TUNDF will print first then on a new line the lexeme for it then add the new line character
        else if(this.getTokenID() == Tokens.TUNDF)
        {
            output += "\nlexical error " + this.getLexeme();
        }
        return output;
    }
}