/*
    COMP3290 Project 2
    Author: Shaan Arora, C3236359
    OutputController Class
        Contains all functionality to create a listing file, generate the output for all structures of the compiler and report errors
 */

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

public class OutputController
{
    //Private Member Variables

    //The file that has been read which is stored as a StringBuilder object by a LexicalScanner object
    private StringBuilder input;
    //Current line number, used for when writing the listing file with the line number at the start of each line
    private int currentLineNo;
    //Stores all valid Token objects generated by a LexicalScanner object
    private ArrayList<Token> tokenStream;
    //Stores all Token objects that classify as a lexical error so after the program listing we can output them all with their associated line number
    //  this will store Token objects of Tokens enum type TUNDF
    private StringBuilder lexicalErrors;
    //Count of how many lexical errors were found
    private int totalLexicalErrors;
    //StringBuilder object that will store syntax errors sent by a SyntaxTree object as String
    private StringBuilder syntaxErrors;
    //Counter for the number of syntax tree nodes and their associated attribute on a single output line
    private int syntaxOutputCount;
    //Total number of syntax errors found
    private int totalSyntaxErrors;
    //StringBuilder object to collect and store semantic errors sent by a SyntaxTree during parsing since semantic checking is done during parsing
    private StringBuilder semanticErrors;
    //Total number of semantic errors found
    private int totalSemanticErrors;


    //Default Constructor
    public OutputController()
    {
        this.input = new StringBuilder();
        this.currentLineNo = 1;
        //Lexical related private member variables
        this.tokenStream = new ArrayList<>();
        this.lexicalErrors = new StringBuilder();
        this.totalLexicalErrors = 0;
        //Syntax related private member variables
        this.syntaxErrors = new StringBuilder();
        this.syntaxOutputCount = 0;
        this.totalSyntaxErrors = 0;
        //Semantic related private member variables
        this.semanticErrors = new StringBuilder();
        this.totalSemanticErrors = 0;
    }

    //Operational Methods

    //Preconditions:  LexicalScanner & OutputController object have been declared and initialized.
    //                  readFile() call from the LexicalScanner object to read the source file
    //                  setInput() with the LexicalScanner object getInput() call as its parameter to populate the OutputController objects input private member variable
    //Postconditions: Creates a file with the name of which is whatever the value of fileName is and then writes the original source code to that file
    //                  with the line numbers at the very beginning of each line
    public void generateListingFile(String fileName)
    {
        assert this.getInput().length() != 0;
        try
        {
            //Creates a new file with the name of the String value passed in
            FileWriter fw = new FileWriter(fileName);
            //Augment our original input to include the line number at the beginning of each line which is returned as a StringBuilder object
            //the String version of that StringBuilder object is written to the file created above
            String output = this.augmentInput().toString();
            fw.write(output);
            //If no errors have been found at all
            if(this.totalLexicalErrors == 0 && this.totalSyntaxErrors == 0 && this.totalSemanticErrors == 0)
            {
                fw.write("\n\nNo errors found");
            }
            else
            {
                //write the error tokens at the end of the file
                fw.write("\n\nLexical Errors Found (" + this.totalLexicalErrors + "):\n");
                //Write formatted error message to the listing file
                fw.write(this.lexicalErrors.toString());
                //Display a heading for the syntax errors found and how many were found during parsing
                fw.write("\nSyntax Errors Found (" + this.totalSyntaxErrors + "):\n");
                //write all syntax errors to the listing file
                fw.write(this.syntaxErrors.toString());
                //Display a heading for the semantic errors found and how many were found during parsing
                fw.write("\nSemantic Errors Found (" + this.totalSemanticErrors + "):\n");
                //write all semantic errors to the listing file
                fw.write(this.semanticErrors.toString());
            }
            fw.close();
        }
        catch (IOException e) {e.printStackTrace();}
    }

    //Helper Function for generateListingFile()
    //Preconditions: LexicalScanner & OutputController object have been declared and initialized.
    //                  readFile() from the LexicalScanner object have been called
    //                  setInput() with the LexicalScanner object getInput() call as its parameter to populate the OutputController objects input private member variable
    //PostConditions: Augments the StringBuilder object of the current OutputController to have the line number at the start of each line
    private StringBuilder augmentInput()
    {
        //make sure that we actually have a file read in and input has been populated
        assert this.getInput().length() != 0;
        //Create a new StringBuilder object that is a copy of the private member StringBuilder object
        //might change it to this.getInput().toString()
        StringBuilder output = new StringBuilder(this.getInput());
        //Augment the new output StringBuilder object for the first line
        //using insert with an offset such that we can put the line number at the very beginning
        output.insert(0, this.getCurrentLineNo() + " ");
        //increment the marker so we start the for loop at line number 2
        this.currentLineNo++;
        //might have to do output.length() - 1 because of indexing issues
        for(int i = 0; i < output.length(); i++)
        {
            //chec if the char at index i is the new line character
            if(output.charAt(i) == '\n')
            {
                //if the char after the new line character is the special end of file character
                //then remove both chars
                //setLength() sets the internal buffer size of the StringBuilder object and works better than deleteCharAt(int)
                if(output.charAt(i+1) == '\u001a')
                {
                    output.setLength(output.length() - 2);
                    break;
                }
                //every time we reach a new line char add the line number at the start of the new line
                //the offset for the insert function is the char after the new line character
                output.insert(i+1, this.getCurrentLineNo() + " " );
                //update the marker that keeps track of which line number we are up to
                this.currentLineNo++;
            }
        }
        //output.setLength(output.length() - 1);
        //Return the StringBuilder object which is an augmented version of the original input
        return output;
    }

    //Preconditions: ls has been declared & initialized, readFile() has been called on that object
    //Postconditions: Outputs the LexicalScanner object passed in to the terminal as per the specs of assignment 1
    public void outputLexicalScanner(LexicalScanner ls)
    {
        //Enforce preconditions
        assert ls != null : "Make sure that the LexicalScanner object passed in has been declared and initalized";
        ls.tokenize();
    }

    //Preconditions:  st.getRoot() != null, if the root node is null then nothing can be displayed
    //Postconditions: Displays the Abstract Syntax Tree passed in to the terminal
    public void outputSyntaxTree(SyntaxTree st)
    {
        assert st.getRoot() != null : "No Abstract Syntax Tree to display";
        STNode temp = st.getRoot();
        this.preorderTraversal(temp);
    }

    //Helper function for outputSyntaxTree
    //Preconditions:  None
    //Postconditions: Displays the Abstract Syntax Tree to the terminal in its preorder form
    private void preorderTraversal(STNode node)
    {
        if(node == null){return;}
        this.syntaxOutputCount += node.toString().length();
        if(this.syntaxOutputCount <= 70) System.out.print(node);
        else
        {
            System.out.print(node);
            System.out.print('\n');
            this.syntaxOutputCount = 0;
        }
        this.preorderTraversal(node.getLeftChild());
        this.preorderTraversal(node.getMiddleChild());
        this.preorderTraversal(node.getRightChild());
    }

    //Preconditions:  t != null
    //Postconditions: t is added to the list of lexically valid token
    public void addValidToken(Token t)
    {
        //make sure that we are not adding a null object to the list
        assert t != null;
        this.tokenStream.add(t);
    }

    //Preconditions:  e must have the Tokens enum value of TUNDF/62
    //Postconditions: e is added to the list of lexical errors
    public void addLexicalError(Token e)
    {
        //make sure that the Token object passed in is classified as a lexical error
        assert e.getTokenID() == Tokens.TUNDF;
        //update the number of lexical errors found
        this.totalLexicalErrors++;
        //use the Token object to generate an error message string
        this.lexicalErrors.append(String.format("Line %d, Column %d: %s\n", e.getLineNo(), e.getColNo(), e.getLexeme()));
    }

    //Preconditions:  s != "" (empty string)
    //Postconditions: Adds the string passed in to the StringBuilder object containing all syntax errors found during parsing
    public void addSyntaxError(String s)
    {
        //make sure we do not have an empty string
        assert !s.equals("");
        //update the count of how many syntax errors have been found during parsing
        this.totalSyntaxErrors++;
        //add the string passed in to the StringBuilder object holding all syntax errors found
        this.syntaxErrors.append(s);
    }

    //Preconditions:  s != "" (empty string)
    //Postconditions: Adds the string passed in to the StringBuilder object containing all semantic errors found during parsing
    public void addSemanticError(String s)
    {
        //make sure we do not have an empty string
        assert !s.equals("");
        //update the count of how many semantic errors have been found during parsing
        this.totalSemanticErrors++;
        //add the string passed in to the StringBuilder object holding all semantic errors found
        this.semanticErrors.append(s);
    }

    //Preconditions:  OutputController has been declared & intialized
    //Postconditions: Returns true if no lexical, syntax and semantic errors were found during compilation
    public boolean errorFree()
    {
        return this.totalLexicalErrors == 0 && this.totalSyntaxErrors == 0 && this.totalSemanticErrors == 0;
    }

    //Setters

    //Preconditions: A LexicalScanner object has been declare & intialized and then readFile() has been called to generate its own StringBuilder to pass in
    //Postconditions: Assigns the StringBuilder object of i to the private member variable of the current OutputController object
    public void setInput(StringBuilder i) {this.input = i;}

    //Preconditions: None
    //Postconditions: Assigns the value of l to the currentLineNo of the current OutputController object
    public void setCurrentLineNo(int l) {this.currentLineNo = l;}

    //Preconditions: A LexicalScanner object has been declared & initialized followed by readFile() and then getToken() or nextToken() to generate at least one Token object
    //                  so we can pass in that object's stream into the current OutputController object
    //Postconditions: Assigns an ArrayList object of type Token that is acting as storage for all Token objects generated by a LexicalScanner object
    public void setTokenStream(ArrayList<Token> t) {this.tokenStream = t;}

    //Preconditions: An OutputController & a LexicalScanner object have both been declared & initialized.
    //                  The LexicalScanner object needs to have called readFile() followed by getToken() or nextToken() so that at least one Token object is generated
    //                  The OutputController needs to have called setTokens()
    //Postconditions: Assigns an ArrayList of type Token that contains any Token objects that have been classified as a lexical error by a LexicalScanner object
    public void setLexicalErrors(StringBuilder le) {this.lexicalErrors = le;}

    //Preconditions:
    //Postconditions:
    public void setSyntaxErrors(StringBuilder sb) {this.syntaxErrors = sb;}

    public void setTotalSyntaxErrors(int s) {this.totalSyntaxErrors = s;}


    //Getters

    //Preconditions: A LexicalScanner objject has been declared & initialized and readFile() has been called
    //               Current OutputController object has been declared & initialized and setInput() has been called passing in the StringBuilder object generated
    //                  by the LexicalScanner object as a result of readFile() being called
    //Postconditions: Returns a StringBuilder object containing the entire file that has been read by a LexicalScanner object
    public StringBuilder getInput() {return this.input;}

    //Preconditions: Current OutputController has been declared & initialized
    //Postconditions: Returns how many lines the object is currently up to in regards to generating a listing file with the line numbers at the start of each line
    public int getCurrentLineNo() {return this.currentLineNo;}

    //Preconditions: A LexicalScanner object has been declared & initialized, readFile() and getToken() or nextToken() has been called
    //               Current OutputController object has been declared and initialized and setTokens() has been called passing in the ArrayList generated by the
    //                  LexicalScanner object
    //PostConditions: Returns an ArrayList object of type Token that contains all Token objects generated by a LexicalScanner object
    public ArrayList<Token> getTokenStream() {return this.tokenStream;}

    //Preconditions: An OutputController & a LexicalScanner object have both been declared & initialized.
    //                  The LexicalScanner object needs to have called readFile() followed by getToken() or nextToken() so that at least one Token object is generated
    //                  The OutputController needs to have called setTokens() with the ArrayList generated by the LexicalScanner object passed in
    //Postconditions: Returns an ArrayList of type Token that contains any Token objects that have been classified as a lexical error by a LexicalScanner object
    public StringBuilder getLexicalErrors() {return this.lexicalErrors;}

    public StringBuilder getSyntaxErrors() {return this.syntaxErrors;}

    public int getTotalSyntaxErrors() {return this.totalSyntaxErrors;}

    public int getSyntaxOutputCount() {return this.syntaxOutputCount;}

}