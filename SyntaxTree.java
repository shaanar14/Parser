/*
    COMP3290 Project
    Author: Shaan Arora, C3236359
    SyntaxTree Class
        An abstract syntax tree data structure to represent the underlying structure of a CD20 program.
        Each node in the tree represents an operator and its children an operand
 */

import org.w3c.dom.Node;

//TODO reorder grammar rule functions
public class SyntaxTree
{
    //Private member variables

    //The root of the syntax tree
    private STNode root;
    //Lexical Scanner object so we can get the next lexeme
    private LexicalScanner scanner;
    //The next Token which is read by lookahead
    private Token next;
    //OutputController object for errors & listings
    private OutputController output;

    //Default Constructor
    public SyntaxTree()
    {
        this.root = new STNode();
        this.scanner = new LexicalScanner();
        this.next = new Token();
        this.output = new OutputController();
    }

    //Preorder traversal of the Abstract Syntax tree for the output
    public void preorder(STNode node)
    {
        if(node == null){return;}
        preorder(node.getLeftChild());
        preorder(node.getRightChild());
        System.out.print(node.getNodeValue());
    }

    //Only want this function to be public as this will just recursively generate the tree for us from the root node down
    //Dont want to return the root node because that exposes the entire tree
    public void generateTree()
    {
        //Generate the first valid token
        this.nextToken();
        //Recursively generate the Abstract Syntax Tree
        this.setRoot(this.program());
    }


    //Preconditions:  The current SyntaxTree object has been properly declared & intialized
    //Postconditions: Display the AST in pre order notation in the terminal
    public void outputTree() {this.output.outputSyntaxTree(this);}

    //Recursive functions based on the CD20 grammar after it has been left factored and transformed into a LL(1) grammar
    //  Any rules in the grammar that have the node value Special do not create nodes but instead collapse up to the next rule which does have a node value
    //  Anything not wrapped in <> are specific keywords
    //  <id> , <structid> & <typeid> are all identifier Tokens generated by the scanner
    //  <ilit> , <reallit> & <string> are all special Tokens generated by the scanner

    //Preconditions:
    //Postconditions:
    //Rule: NPROG <program> ::= CD20 <id> <global> <funcs> <mainbody>
    private STNode program()
    {
        //NPROG
        STNode prog = new STNode(NodeValue.NPROG);
        //TODO below
        //need to capture CD20 token which
        //then need to capture identifier token afterwards
        //identifier token needs to go into symbol table somehow and then prog.setRecord() on that entry
        //then call nextToken()
        this.nextToken();
        //could also do this.next.getTokenID() == 2
        if(this.next.getIDLabel() == Tokens.TCONS || this.next.getIDLabel() == Tokens.TTYPS || this.next.getIDLabel() == Tokens.TARRS)
        {
            prog.setLeftChild(this.globals());
        }
        else if (this.next.getIDLabel() == Tokens.TFUNC)
        {
            prog.setMiddleChild(this.funcs());
        }
        prog.setRightChild(this.mainbody());
        return prog;
    }

    //Rule: NGLOB <globals> ::= <consts> <types> <arrays>
    private STNode globals()
    {
        STNode consts = this.consts();
        STNode types = this.types();
        STNode arrays = this.arrays();
        //Return a STNode object with a NodeValue of NGLOB
        return new STNode(NodeValue.NGLOB, consts, types, arrays);
    }

    //Rule: Special <consts> ::= constants <initlist> | epsilon
    private STNode consts()
    {
        this.nextToken();
        //If we match and consume the constants keyword then return initlist otherwise
        // we don't have a constants keyword and we just return an empty node which I think is the epsilon path
        return this.match(Tokens.TCNST) ? this.initlist() : new STNode();
    }

    //Original Rule:        NILIST <initlist> ::= <init> | <init> , <initlist>
    //After Left Factoring: NILIST <initlist> ::= <init> {epsilon | , <initlist>}
    private STNode initlist()
    {
        STNode tr1, tr2;
        //Only one <init> epsilon path
        tr1 = this.init();
        if(this.next.getTokenID() == 32)
        {
            this.nextToken();
            tr2 = this.initlist();
            return new STNode(NodeValue.NILIST, tr1, tr2);
        }
        return tr1;
    }

    //Rule: NINIT <init> ::= <id> = <expr>
    //TODO add symbol table entry creation after we consume the identifier and equal sign
    private STNode init()
    {
        //Consume <id> which will be an identifier Token object
        boolean consumed1 = this.match(Tokens.TIDEN);
        //Consume the equal symbol
        boolean consumed2 = this.match(Tokens.TEQUL);
        //TODO rework
        if(!consumed1)
        {
            if(!consumed2)
            {
                //If both match() return false then send error message
                this.error("Identifier and equal sign required");
            }
            //If we havent matched an identifier but we have seen an equal sign then error message
            this.error("Identifier required");
        }
        STNode expr = this.expr();
        return new STNode(NodeValue.NINIT, expr);
    }

    //Rule: Special <types> ::= types <typelist> | epsilon
    private STNode types()
    {
        this.nextToken();
        //Same logic as consts()
        //consume types keyword and return a STNode object from typelist otherwise return an empty object which is the epsilon path
        return this.match(Tokens.TTYPS) ? this.typelist() : new STNode();
    }

    //Original Rule:         NTYPEL <typelist> ::=  <type> <typelist> | <type>
    //After Left Factoring:  NTYPEL <typelist> ::=  <type> {epsilon | <typelist>}
    private STNode typelist()
    {
        STNode t1, t2;
        t1 = this.type();
        //epsilon path
        //recursive call typelist()
        //t2 = this.typelist();
        return t1;
    }

    //TODO possibly need to be left factored
    //Rules: NRTYPE <type> ::= <stuctid> is <fields> end
    //       NATYPE <type> ::= <typeid> is arrrays [ <expr> ] of <structid>
    private STNode type()
    {
        //match identifier token, this is for both <structid> and <typeid> as they are both identifiers
        //TODO possibly have to do something with the symbol table here
        this.match(Tokens.TIDEN);
        //match is keyword
        this.match(Tokens.TTTIS);
        STNode type = new STNode(NodeValue.NATYPE);
        //for second rule where we have is arrays
        if(this.next.getTokenID() == 5)
        {
            //if the token object is arrays then generate the next valid token object from the scanner
            this.nextToken();
            //match left square bracket
            this.match(Tokens.TLBRK);
            //Set the left child of type to be the STNode object returned by expr()
            type.setLeftChild(this.expr());
            //match right square bracket
            this.match(Tokens.TRBRK);
            //match of keyword
            this.match(Tokens.TTTOF);
            //match identifier token for <structid>
            this.match(Tokens.TIDEN);
        }
        else
        {
            //if this.next is not arrays then we have the first rule
            type.setLeftChild(this.fields());
            this.match(Tokens.TTEND);
        }
        return type;
    }

    //Rule: Special <arrays> ::=  arrays <arraydecls> | epsilon
    private STNode arrays()
    {
        this.nextToken();
        //Same logic as consts() and types()
        return this.match(Tokens.TARRS) ? this.arraydecls() : new STNode();
    }

    //Left Factored like initlist
    //Original Rule:        NALIST <arrdecls> ::= <arrdecl> , <arrdecls> | <arrdecl>
    //After Left Factoring: NALIST <arrdecls> ::= <arrdecl> {epsilon | , <arrdecls>}
    private STNode arraydecls()
    {
        STNode a1 = null, a2 = null;
        a1 = arrdecl();
        //Check for coma
        if(this.next.getTokenID() == 32)
        {
            this.nextToken();
            a2 = arraydecls();
            //NALIST
            return new STNode(NodeValue.NALIST, a1, a2);
        }
        //Only one <arrdecl> present so epsilon path
        return a1;
    }

    //Rule: NARRD <arrdecl> ::= <id> : <typeid>
    //TODO create symbol table entry object and fix this.error() calls
    private STNode arrdecl()
    {
        //match & consume identifier token for <id>
        boolean consumedID = this.match(Tokens.TIDEN);
        //match & consume identifier token for :
        boolean consumedColon = this.match(Tokens.TCOLN);
        //match & consume identifier token for <typeid>
        boolean consumedTID = this.match(Tokens.TIDEN);
        if(!consumedID)
        {
            if(!consumedColon)
            {
                if(!consumedTID)
                {
                    this.error("Identifier, colon and another identifier required");
                }
                this.error("Identifier and colon required");
            }
            this.error("Identifier required");
        }
        return new STNode(NodeValue.NARRD);
    }

    //Rule: NMAIN <mainbody> ::= main <slist> begin <stats> end CD20 <id>
    private STNode mainbody()
    {
        //match main keyword
        this.match(Tokens.TMAIN);
        STNode slist = this.slist();
        //match begin keyword
        this.match(Tokens.TBEGN);
        STNode stats = this.stats();
        //match end keyword
        this.match(Tokens.TTEND);
        //match CD20 keyword
        this.match(Tokens.TCD20);
        //match identifier token for <id> which needs to also match the symbol table entry for the same identifier token for the very first CD20 token
        this.match(Tokens.TIDEN);
        //Return a STNode object with the NodeValue NMAIN, slist as its left child & stats as its right child
        return new STNode(NodeValue.NMAIN, slist, stats);
    }

    //Original Rule:       NSDLST <slist> ::= <sdecl> , <slist> | <sdecl> | epsilon
    //After Left Factoring NSDLST <slist> ::= <sdecl> {epsilon| , <slist>}
    private STNode slist()
    {
        STNode sdecl, slist;
        sdecl = this.sdecl();
        //check to see if we have a coma
        if(this.next.getTokenID() == 32)
        {
            //generate next valid token
            this.nextToken();
            slist = this.slist();
            return new STNode(NodeValue.NSDLST, sdecl, slist);
        }
        return sdecl;
    }

    //Rule: NSDECL <sdecl> ::= <id> : int | <id> : real | <id> : bool
    //TODO fix/change whats returned
    private STNode sdecl()
    {
        //match identifier token for <id>
        this.match(Tokens.TIDEN);
        //match colon token for :
        this.match(Tokens.TCOLN);
        //14 for int , 15 for real and 16 for bool
        if(this.next.getTokenID() == 14 || this.next.getTokenID() == 15 || this.next.getTokenID() == 16)
        {
            return new STNode(NodeValue.NSDECL);
        }
        this.error("int or real or bool keyword not found");
        return new STNode();
    }

    //Original Rule:        NFLIST <fields> ::= <sdecl> , <fields> | <sdecl>
    //After Left Factoring: NFLIST <fields> ::= <sdecl> {epsilon | , <fields>}
    private STNode fields()
    {
        STNode f1, f2;
        f1 = this.sdecl();
        if(this.next.getTokenID() == 32)
        {
            //generate next valid token object from the scanner
            this.nextToken();
            f2 = this.fields();
            return new STNode(NodeValue.NFLIST, f1, f2);
        }
        //Epsilon path
        return f1;
    }


    //Rule:          NFUNCS <funcs> ::= <func> <funcs> | <func>
    //Left Factored: NFUNCS <funcs> ::= <func> {epsilon | <funcs>}
    private STNode funcs()
    {
        STNode func = new STNode(), funcs;
        //if the next token is the keyword func
        if(this.next.getTokenID() == 11)
        {
            func = this.func();
            return func;
        }
        funcs = this.funcs();
        return new STNode(NodeValue.NFUNCS, func, funcs);
    }

    //Rule: NFUND <func> ::= func <id> ( <plist> ) : <rytpe> <funcbody>
    //I removed <stype> which means <rtype> ::= int | real | bool | void
    //TODO change whats returned
    private STNode func()
    {
        //Only way we enter this function is if next is the func keyword
        //  so generate the next valid token
        //TODO either call next token here or before this function call in funcs()
        this.nextToken();
        //match identifier token for <id>
        this.match(Tokens.TIDEN);
        //match left parantheses token for (
        this.match(Tokens.TLPAR);
        //call plist() for <plist>
        //<plist> ::= <params> | epsilon
        STNode plist = this.plist();
        //match right parantheses token for )
        this.match(Tokens.TRPAR);
        //match colon token for :
        this.match(Tokens.TCOLN);
        //check for int or real or bool or void for <rtype>
        if(this.next.getTokenID() == 12 || this.next.getTokenID() == 14 || this.next.getTokenID() == 15 || this.next.getTokenID() == 16)
        {
            //call funcbody() for <funcbody>
            STNode funcbody = this.funcbody();
            //Return a STNode object with the NodeValue NFUND, plist as left child, rtype as middle child and funcbody as right child
            return new STNode(NodeValue.NFUND, plist, funcbody);
        }
        else
        {
            this.error("int or real or bool or void not found");
        }
        return new STNode();
    }

    private STNode plist() {return new STNode();}
    private STNode funcbody() {return new STNode();}

    private STNode stats() {return new STNode();}

    //Rule: NSIMV <var> ::= <id>
    //      NARRV <var> ::= <id> [ <expr ] . <id>
    private STNode var()
    {
        STNode var, expr;
        //Match & check for identifier token which is the start of the rule, <id>
        this.match(Tokens.TIDEN);
        //check for left bracket; <id> [
        if(this.next.getTokenID() == 33)
        {
            //generate the next valid token
            this.nextToken();
            expr = this.expr();
            //match & check for ] in <expr> ]
            this.match(Tokens.TRBRK);
            //match and check for . which is after the ]
            this.match(Tokens.TDOTT);
            //match & check for identifier token, <id> at the end of the rule
            this.match(Tokens.TIDEN);
            //Rule has been satisifed completely so we set the node value of var to be NARRV
            //expr will be the left child of var
            var = new STNode(NodeValue.NARRV, expr);
            return var;
        }
        //if we dont have the [ after <id> then we just have the NSIMV rule
        var = new STNode(NodeValue.NSIMV);
        return var;
    }


    //Original Rule:                 NBOOL <bool>     ::= <bool> <logop> <rel> | <rel>
    //After removing left recursion: NBOOL <bool>     ::= <rel> <booltail>
    //                                     <booltail> ::= <logop> <rel> <booltail> | epsilon
    private STNode bool()
    {
        STNode rel = this.rel();
        return this.booltail(rel);
    }

    //Rule: <logop> <rel> <booltail> | epsilon
    private STNode booltail(STNode left)
    {
        STNode parent = null, right;
        //possibly need to call this.nextToken() to generate the next valid token
        if(this.next.getTokenID() == 27 || this.next.getTokenID() == 28 || this.next.getTokenID() == 29)
        {
            NodeValue nv = null;
            //AND
            if(this.next.getTokenID() == 27) nv = NodeValue.NAND;
            //OR
            if(this.next.getTokenID() == 28) nv = NodeValue.NOR;
            //XOR
            if(this.next.getTokenID() == 29) nv = NodeValue.NXOR;
            //Assign the node value above to parent and set its left child to left
            parent = new STNode(nv,left);
            //Generate next valid Token object from the scanner
            this.nextToken();
            right = rel();
            parent.setRightChild(right);
            return booltail(parent);
        }
        //Error check/recovery here?
        return left;
    }

    //Rules: NNOT    <rel> ::= not <expr> <relop> <expr>
    //       Special <rel> ::= <expr> <relop> <expr> | <expr>
    //After Left Factoring: <rel> ::= <expr> <relop> <expr> {not | <expr>}
    //TODO fix
    private STNode rel()
    {
        STNode rel = new STNode();
        //left/first <expr>
        STNode exprL = this.expr();
        STNode relop = this.relop();
        //right/second <expr>
        STNode exprR = this.expr();
        //check for not keyword
        if(this.next.getTokenID() == 26)
        {
            //node value of NNOT
            rel = new STNode(NodeValue.NNOT, exprL, relop, exprR);
            return rel;
        }
        return rel;
    }


    //Rule  NADD <expr> ::= <term> <exprtail>
    //      NSUB <expr> ::= <term> <exprtail>
    private STNode expr()
    {
        STNode term = this.term();
        return this.exprtail(term);
    }

    //Rule: <exprtail> ::= + <term> <facttail> | - <term> <facttail> | epsilon
    private STNode exprtail(STNode left)
    {
        STNode tail, term;
        //check for +
        if(this.next.getTokenID() == 38)
        {
            this.nextToken();
            term = this.term();
            //node value for NADD
            //term becomes the left child
            tail = new STNode(NodeValue.NADD, term);
            return tail;
        }
        //check for -
        if(this.next.getTokenID() == 39)
        {
            this.nextToken();
            term = this.term();
            //node value for NADD
            //term becomes the left child
            tail = new STNode(NodeValue.NSUB, term);
            return tail;
        }
        //epsilon path
        return left;
    }

    //Combined all three rules into one function
    //Original Rules:       NMUL <term> ::= term * fact | fact
    //                      NDIV <term>::= term / fact | fact
    //                      NMOD <term> ::= term % fact | fact
    //After left Factoring: NMUL <term> ::= <fact> {epsilon | * <term>}
    //                      NDIV <term> ::= <fact> {epsilon | / <term>}
    //                      NMOD <term> ::= <fact> {epsilon | % <term>}
    private STNode term()
    {
        STNode term, fact;
        fact = this.fact();
        if(this.next.getTokenID() == 40 || this.next.getTokenID() == 41 || this.next.getTokenID() == 42)
        {
            //generate next valid token
            this.nextToken();
            term = this.term();
            if(this.next.getTokenID() == 40) return new STNode(NodeValue.NMUL, term, fact);
            if(this.next.getTokenID() == 41) return new STNode(NodeValue.NDIV, term, fact);
            if(this.next.getTokenID() == 42) return new STNode(NodeValue.NMOD, term, fact);
        }
        //epsilon path
        return fact;
    }

    // OR <exponent> came from <fact> ::= <exponent> and OR <var> comes from <exponent> ::= <var>
    //Original Rule:        NPOW <fact> ::= <fact> ^ <exponent> | <exponent> | <var>
    //After Left Factoring: NPOW <fact> ::= <exponent> <facttail>
    private STNode fact()
    {
        STNode exp = this.exponent();
        return this.facttail(exp);
    }

    //Rule  <facttail> ::= ^ <exponent> <facttail> | epsilon
    private STNode facttail(STNode left)
    {
        STNode parent, right;
        if(this.next.getTokenID() == 43)
        {
            //we have foudn the ^ so generate the next valid token
            this.nextToken();
            parent = new STNode(NodeValue.NPOW, left);
            right = this.exponent();
            parent.setRightChild(right);
            return booltail(parent);
        }
        return left;
    }

    //<exponent>
    private STNode exponent()
    {
        //<exponent> ::= <intlit>
        if(this.next.getTokenID() == 59) return new STNode(NodeValue.NILIT);
        //<exponent> ::= <reallit>
        if(this.next.getTokenID() == 60) return new STNode(NodeValue.NFLIT);
        //<exponent> ::= true
        if(this.next.getTokenID() == 30) return new STNode(NodeValue.NTRUE);
        //<exponent> ::= false
        if(this.next.getTokenID() == 31) return new STNode(NodeValue.NFALS);
        //<exponent> ::= ( <bool> )
        if(this.next.getTokenID() == 35)
        {
            //( for ( <bool> )
            this.nextToken();
            return this.bool();
        }
        //<exponent> ::= <fncall>
        if(this.next.getTokenID() == 58)
        {
            //identifier token which is the start of <fncall>
            this.nextToken();
            return this.fncall();
        }
        //<exponent> ::= <var>
        return this.var();
    }

     private STNode fncall() {return new STNode();}

    //TODO rework
    private boolean match(Tokens t)
    {
        if(this.next.getTokenID() == t.getID())
        {
            this.nextToken();
            return true;
        }
        else
        {
            this.error(this.next);
            return false;
        }
    }

    //Message style error reporting function
    //TODO rework for error recovery
    private void error(String s)
    {
        String e = "Syntax Error: " + s;
        this.getOutput().addSyntaxError(e);
    }

    //Token based error reporting function
    //TODO rework for error recovery
    private void error(Token t)
    {
        String e = String.format("Line %d, Column %d: %s\n", t.getLineNo(), t.getColNo(), t.getLexeme());
        this.getOutput().addSyntaxError(e);
    }

    //Setters

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The root of the current object is assigned the STNode r
    public void setRoot(STNode r) {this.root = r;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The LexicalScanner object of the current object is assigned the value of ls
    public void setScanner(LexicalScanner ls) {this.scanner = ls;}

    //Normal setter for next
    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The next Token object of the current object is assigned the value of t
    public void setNext(Token t) {this.next = t;}

    //Secondary setter for next in which the LexicalScanner object of the SyntaxTree will generate the next valid token and assign it to next
    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: A new Token object is generated by the LexicalScanner object and assigned to the current objects next
    public void nextToken()
    {
        //While the scanner generates lexically invalid Token objects
        while(this.next.getTokenID() == 62)
        {
            //Send the invalid Token Object to the output controller so we can report the error
            this.output.addLexicalError(this.next);
            //Generate the next Token object from our scanner, if its valid then the loop will end
            this.next = this.scanner.nextToken();
        }
        //Since next does not have an ID of 62 then its a lexically valid Token object so send it to the OutputController
        this.output.addValidToken(this.next);
    }

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The OutputController object of the current SyntaxTree object that is used for errors is assigned the value of oc
    public void setOutput(OutputController oc) {this.output = oc;}

    //Getters

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the root STNode of the current SyntaxTree object
    public STNode getRoot() {return this.root;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the LexicalScanner object of the current SyntaxTree object which is used for tokenizing
    public LexicalScanner getScanner() {return this.scanner;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the Token object which is being used as a look ahead after the grammar has been left factored into a LL(1) grammar
    public Token getNext() {return this.next;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the OutputController of the SyntaxTree that is being used for handling and displaying errors
    public OutputController getOutput() {return this.output;}
}
