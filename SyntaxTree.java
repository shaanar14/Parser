/*
    COMP3290 Project
    Author: Shaan Arora, C3236359
    SyntaxTree Class
        An abstract syntax tree data structure to represent the underlying structure of a CD20 program.
        Each node in the tree represents an operator and its children an operand
 */

import org.w3c.dom.Node;

//TODO reorder grammar rule functions
public class SyntaxTree
{
    //Private member variables

    //The root of the syntax tree
    private STNode root;
    //Lexical Scanner object so we can get the next lexeme
    private LexicalScanner scanner;
    //The next Token which is read by lookahead
    private Token next;
    //OutputController object for errors & listings
    private OutputController output;

    //Default Constructor
    public SyntaxTree()
    {
        this.root = new STNode();
        this.scanner = new LexicalScanner();
        this.next = new Token();
        this.output = new OutputController();
    }

    //Preorder traversal of the Abstract Syntax tree for the output
    public void preorder(STNode node)
    {
        if(node == null){return;}
        preorder(node.getLeftChild());
        preorder(node.getRightChild());
        System.out.print(node.getNodeValue());
    }

    //Only want this function to be public as this will just recursively generate the tree for us from the root node down
    //Dont want to return the root node because that exposes the entire tree
    public void generateTree()
    {
        //Generate the first valid token
        this.nextToken();
        //Recursively generate the Abstract Syntax Tree
        this.setRoot(this.program());
    }

    //Preconditions:  The current SyntaxTree object has been properly declared & intialized
    //Postconditions: Display the AST in pre order notation in the terminal
    public void outputTree() {this.output.outputSyntaxTree(this);}

    //Recursive functions based on the CD20 grammar after it has been left factored and transformed into a LL(1) grammar
    //  Any rules in the grammar that have the node value Special do not create nodes but instead collapse up to the next rule which does have a node value
    //  Anything not wrapped in <> are specific keywords
    //  <id> , <structid> & <typeid> are all identifier Tokens generated by the scanner
    //  <ilit> , <reallit> & <string> are all special Tokens generated by the scanner

    //Preconditions:
    //Postconditions:
    //Rule: NPROG <program> ::= CD20 <id> <global> <funcs> <mainbody>
    private STNode program()
    {
        //NPROG
        STNode prog = new STNode(NodeValue.NPROG);
        //TODO below
        //need to capture CD20 token which
        //then need to capture identifier token afterwards
        //identifier token needs to go into symbol table somehow and then prog.setRecord() on that entry
        //then call nextToken()
        this.nextToken();
        //could also do this.next.getTokenID() == 2
        if(this.next.getIDLabel() == Tokens.TCONS || this.next.getIDLabel() == Tokens.TTYPS || this.next.getIDLabel() == Tokens.TARRS)
        {
            prog.setLeftChild(this.globals());
        }
        else if (this.next.getIDLabel() == Tokens.TFUNC)
        {
            prog.setMiddleChild(this.funcs());
        }
        prog.setRightChild(this.mainbody());
        return prog;
    }

    //Rule: NGLOB <globals> ::= <consts> <types> <arrays>
    private STNode globals()
    {
        STNode consts = this.consts();
        STNode types = this.types();
        STNode arrays = this.arrays();
        //Return a STNode object with a NodeValue of NGLOB
        return new STNode(NodeValue.NGLOB, consts, types, arrays);
    }

    //Rule: Special <consts> ::= constants <initlist> | epsilon
    private STNode consts()
    {
        this.nextToken();
        //If we match and consume the constants keyword then return initlist otherwise
        // we don't have a constants keyword and we just return an empty node which I think is the epsilon path
        return this.match(Tokens.TCNST) ? this.initlist() : new STNode();
    }

    //Original Rule: NILIST <initlist> ::= <init> | <init> , <initlist>
    //Left Factored: NILIST <initlist> ::= <init> {epsilon | , <initlist>}
    private STNode initlist()
    {
        STNode tr1, tr2;
        //Only one <init> epsilon path
        tr1 = this.init();
        if(this.next.getTokenID() == 32)
        {
            this.nextToken();
            tr2 = this.initlist();
            return new STNode(NodeValue.NILIST, tr1, tr2);
        }
        return tr1;
    }

    //Rule: NINIT <init> ::= <id> = <expr>
    //TODO add symbol table entry creation after we consume the identifier and equal sign
    private STNode init()
    {
        //Consume <id> which will be an identifier Token object
        boolean consumed1 = this.match(Tokens.TIDEN);
        //Consume the equal symbol
        boolean consumed2 = this.match(Tokens.TEQUL);
        //TODO rework
        if(!consumed1)
        {
            if(!consumed2)
            {
                //If both match() return false then send error message
                this.error("Identifier and equal sign required");
            }
            //If we havent matched an identifier but we have seen an equal sign then error message
            this.error("Identifier required");
        }
        STNode expr = this.expr();
        return new STNode(NodeValue.NINIT, expr);
    }

    //Rule: Special <types> ::= types <typelist> | epsilon
    private STNode types()
    {
        this.nextToken();
        //Same logic as consts()
        //consume types keyword and return a STNode object from typelist otherwise return an empty object which is the epsilon path
        return this.match(Tokens.TTYPS) ? this.typelist() : new STNode();
    }

    //Original Rule: NTYPEL <typelist> ::=  <type> <typelist> | <type>
    //Left Factored: NTYPEL <typelist> ::=  <type> {epsilon | <typelist>}
    private STNode typelist()
    {
        STNode t1, t2;
        t1 = this.type();
        //epsilon path
        //recursive call typelist()
        //t2 = this.typelist();
        return t1;
    }

    //TODO possibly need to be left factored
    //Rules: NRTYPE <type> ::= <stuctid> is <fields> end
    //       NATYPE <type> ::= <typeid> is arrrays [ <expr> ] of <structid>
    private STNode type()
    {
        //match identifier token, this is for both <structid> and <typeid> as they are both identifiers
        //TODO possibly have to do something with the symbol table here
        this.match(Tokens.TIDEN);
        //match is keyword
        this.match(Tokens.TTTIS);
        STNode type = new STNode(NodeValue.NATYPE);
        //for second rule where we have is arrays
        if(this.next.getTokenID() == 5)
        {
            //if the token object is arrays then generate the next valid token object from the scanner
            this.nextToken();
            //match left square bracket
            this.match(Tokens.TLBRK);
            //Set the left child of type to be the STNode object returned by expr()
            type.setLeftChild(this.expr());
            //match right square bracket
            this.match(Tokens.TRBRK);
            //match of keyword
            this.match(Tokens.TTTOF);
            //match identifier token for <structid>
            this.match(Tokens.TIDEN);
        }
        else
        {
            //if this.next is not arrays then we have the first rule
            type.setLeftChild(this.fields());
            this.match(Tokens.TTEND);
        }
        return type;
    }

    //Rule: Special <arrays> ::=  arrays <arraydecls> | epsilon
    private STNode arrays()
    {
        this.nextToken();
        //Same logic as consts() and types()
        return this.match(Tokens.TARRS) ? this.arraydecls() : new STNode();
    }

    //Left Factored like initlist
    //Original Rule: NALIST <arrdecls> ::= <arrdecl> , <arrdecls> | <arrdecl>
    //Left Factored: NALIST <arrdecls> ::= <arrdecl> {epsilon | , <arrdecls>}
    private STNode arraydecls()
    {
        STNode a1, a2;
        a1 = arrdecl();
        //Check for coma
        if(this.next.getTokenID() == 32)
        {
            this.nextToken();
            a2 = arraydecls();
            //NALIST
            return new STNode(NodeValue.NALIST, a1, a2);
        }
        //Only one <arrdecl> present so epsilon path
        return a1;
    }

    //Rule: NARRD <arrdecl> ::= <id> : <typeid>
    //TODO create symbol table entry object and fix this.error() calls
    private STNode arrdecl()
    {
        //match & consume identifier token for <id>
        boolean consumedID = this.match(Tokens.TIDEN);
        //match & consume identifier token for :
        boolean consumedColon = this.match(Tokens.TCOLN);
        //match & consume identifier token for <typeid>
        boolean consumedTID = this.match(Tokens.TIDEN);
        if(!consumedID)
        {
            if(!consumedColon)
            {
                if(!consumedTID)
                {
                    this.error("Identifier, colon and another identifier required");
                }
                this.error("Identifier and colon required");
            }
            this.error("Identifier required");
        }
        return new STNode(NodeValue.NARRD);
    }

    //Rule: NMAIN <mainbody> ::= main <slist> begin <stats> end CD20 <id>
    private STNode mainbody()
    {
        //match main keyword
        this.match(Tokens.TMAIN);
        STNode slist = this.slist();
        //match begin keyword
        this.match(Tokens.TBEGN);
        STNode stats = this.stats();
        //match end keyword
        this.match(Tokens.TTEND);
        //match CD20 keyword
        this.match(Tokens.TCD20);
        //match identifier token for <id> which needs to also match the symbol table entry for the same identifier token for the very first CD20 token
        this.match(Tokens.TIDEN);
        //Return a STNode object with the NodeValue NMAIN, slist as its left child & stats as its right child
        return new STNode(NodeValue.NMAIN, slist, stats);
    }

    //Original Rule: NSDLST <slist> ::= <sdecl> , <slist> | <sdecl> | epsilon
    //Left Factored: NSDLST <slist> ::= <sdecl> {epsilon| , <slist>}
    private STNode slist()
    {
        STNode sdecl, slist;
        sdecl = this.sdecl();
        //check to see if we have a coma
        if(this.next.getTokenID() == 32)
        {
            //generate next valid token
            this.nextToken();
            slist = this.slist();
            return new STNode(NodeValue.NSDLST, sdecl, slist);
        }
        return sdecl;
    }

    //Rule: NSDECL <sdecl> ::= <id> : int | <id> : real | <id> : bool
    //TODO fix/change whats returned
    private STNode sdecl()
    {
        //match identifier token for <id>
        this.match(Tokens.TIDEN);
        //match colon token for :
        this.match(Tokens.TCOLN);
        //14 for int , 15 for real and 16 for bool
        if(this.next.getTokenID() == 14 || this.next.getTokenID() == 15 || this.next.getTokenID() == 16)
        {
            return new STNode(NodeValue.NSDECL);
        }
        this.error("int or real or bool keyword not found");
        return new STNode();
    }

    //Original Rule: NFLIST <fields> ::= <sdecl> , <fields> | <sdecl>
    //Left Factored: NFLIST <fields> ::= <sdecl> {epsilon | , <fields>}
    private STNode fields()
    {
        STNode f1, f2;
        f1 = this.sdecl();
        if(this.next.getTokenID() == 32)
        {
            //generate next valid token object from the scanner
            this.nextToken();
            f2 = this.fields();
            return new STNode(NodeValue.NFLIST, f1, f2);
        }
        //Epsilon path
        return f1;
    }


    //Original Rule: NFUNCS <funcs> ::= <func> <funcs>  | <func>
    //Left Factored: NFUNCS <funcs> ::= <func> {epsilon | <funcs>}
    private STNode funcs()
    {
        STNode func = new STNode(), funcs;
        //if the next token is the keyword func
        if(this.next.getTokenID() == 11)
        {
            func = this.func();
            return func;
        }
        funcs = this.funcs();
        return new STNode(NodeValue.NFUNCS, func, funcs);
    }

    //Original Rule: NFUND <func> ::= func <id> ( <plist> ) : <rytpe> <funcbody>
    //I removed <stype> ::= int| real | bool which means <rtype> ::= int | real | bool | void
    //<plist> ::= <params> | epsilon became if statement
    //TODO change whats returned
    private STNode func()
    {
        //Only way we enter this function is if next is the func keyword
        //  so generate the next valid token
        //TODO either call next token here or before this function call in funcs()
        STNode params = new STNode();
        this.nextToken();
        //match identifier token for <id>
        this.match(Tokens.TIDEN);
        //match left parantheses token for (
        this.match(Tokens.TLPAR);
        //TODO <plist> can be epsilon
        //if we have the start of <params> which goes to <param> which starts with either <id> or const keyword
        if(this.next.getTokenID() == 58 || this.next.getTokenID() == 2)
        {
            params = this.params();
        }
        //match right parantheses token for )
        this.match(Tokens.TRPAR);
        //match colon token for :
        this.match(Tokens.TCOLN);
        //check for int or real or bool or void for <rtype>
        if(this.next.getTokenID() == 12 || this.next.getTokenID() == 14 || this.next.getTokenID() == 15 || this.next.getTokenID() == 16)
        {
            //call funcbody() for <funcbody>
            STNode funcbody = this.funcbody();
            //Return a STNode object with the NodeValue NFUND, plist as left child, rtype as middle child and funcbody as right child
            //if <plist> takes epsilon path then params will just be a blank node
            return new STNode(NodeValue.NFUND, params, funcbody);
        }
        this.error("int or real or bool or void not found");
        return new STNode();
    }

    //Original Rule: NPLIST <params> ::= <param> , <params>
    //                      <param>  ::= <sdecl> | <arrdecl> | const <arrdecl>
    //Left Factored: NPLIST <params> ::= <param> {epsilon | , <params>}
    private STNode params()
    {
        STNode param, params;
        param = this.param();
        //check to see if we have a coma for , <params>
        if(this.next.getTokenID() == 32)
        {
            //generate next valid token
            this.nextToken();
            params = this.params();
            return new STNode(NodeValue.NPLIST, param, params);
        }
        //epsilon path
        return param;
    }

    //Rules: NSIMP <param> ::= <sdecl>
    //       NARRP <param> ::= <arrdecl>
    //       NARRC <param> ::= const <arrdecl>
    //TODO need to decide between <sdecl> and <arrdecl>
    private STNode param()
    {
        STNode sdecl, arrdecl;
        //check for const keyword for the rule const <arrdecl>
        if(this.next.getTokenID() == 2)
        {
            //we have seen the const keyword so generate next valid token
            this.nextToken();
            arrdecl = this.arrdecl();
            //Return a node for NodeValue NARCC with arrdecl as left child
            return new STNode(NodeValue.NARRC, arrdecl);
        }
        //<sdecl> and <arrdecl> both start with <id> :
        else if(this.next.getTokenID() == 58)
        {
            sdecl = this.sdecl();
            arrdecl = this.arrdecl();
        }
        return new STNode(NodeValue.NSIMP);
    }

    //Original Rule: Special <funcbody> ::= <locals> begin <stats> end
    //                       <locals>   ::= <dlist> | epsilon
    private STNode funcbody()
    {
        STNode locals, stats;
        //For <locals>:
        //since <dlist> ::= <decl> ::= <sdecl> | <arrdecl> which both start with <id>
        if(this.next.getTokenID() == 58)
        {
            //dont want to generate next valid token because <sdecl> and <arrdecl> start with an identifier token
            locals = this.dlist();
        }
        //check for begin keyword
        this.match(Tokens.TBEGN);
        stats = this.stat();
        //check for end keyword
        this.match((Tokens.TTEND));
        return new STNode();
    }

    //Original Rule: NDLIST <dlist> ::= <decl> , <dlist>
    //                      <dlist> ::= <decl>
    //                      <decl>  ::= <sdecl> | <arrdecl>
    //Left Factored: NDLSIT <dlist> ::= <decl> {epsilon | , <dlist>}
    private STNode dlist()
    {
        STNode decl, dlist;
        decl = this.decl();
        //check for ,
        if(this.next.getTokenID() == 32)
        {
            this.nextToken();
            dlist = this.dlist();
            return new STNode(NodeValue.NDLIST, decl, dlist);
        }
        //epsilon path
        return decl;
    }

    //Rule: Special <decl> ::= <sdecl> | <arrdecl>
    //TODO change whats returned
    private STNode decl()
    {
        //check of <id> which is the start of both rules
        this.match(Tokens.TIDEN);
        //check for : which comes after <id> in both rules
        this.match(Tokens.TCOLN);
        //if we have the keywords int or real or bool then that satisfies <decl> ::= <sdecl>
        if(this.next.getTokenID() == 14 || this.next.getTokenID() == 15 || this.next.getTokenID() == 16)
        {
            //generate next valid token
            this.nextToken();
            //Return a node with NSDECL
            return new STNode(NodeValue.NSDECL);
        }
        //if we have an identifier after the coln then we can satisfy <decl> ::= <arrdecl>
        if(this.next.getTokenID() == 58)
        {
            //generate next valid token
            this.nextToken();
            //Return a node with NARDD
            return new STNode(NodeValue.NARRD);
        }
        return new STNode();
    }

    //unsure if I should left factor it
    //Original rules: NSTATS <stats> ::= <stat> ; <stats> | <strstat> <stats>
    //                       <stats> ::= <stat> ; | <strstat>
    //Left Factored:  NSTATS <stats> ::= <stat> ; | <strstat> {epsilon | <stats>}
    //TODO fix
    private STNode stats()
    {
        //stat1 for <stat> and stat2 for <strstat> and stats for recursive call
        STNode stat1, stat2, stats;
        //need to decide which rule to satisfy
        stat1 = this.stat();
        stat2 = this.strstat();
        //check for ;
        if(this.next.getTokenID() == 56)
        {
            //generate next valid token
            this.nextToken();
            stats = this.stats();
            return new STNode(NodeValue.NSTATS, stat1, stats);
        }
        return new STNode(NodeValue.NSTATS, stat1, stat2);
    }

    //TODO implement <asgnstat> and <callstat> case
    //Rule: Special <stat> ::= <repstat> | <asgnstat> | <iostat> | <callstat> | <returnstat>
    //<asgnstat> and <callstat> clash because <asgnstat> starts with <var> which starts with <id> and <callstat> starts with <id>
    private STNode stat()
    {
        return switch (this.next.getTokenID())
        {
            case 18 -> this.repstat();
            case 22, 23, 24 -> this.iostat();
            case 25 -> this.returnstat();
            default -> new STNode();
        };
    }

    //Rule: <Special> <strstat> ::= <forstat> | <ifstat>
    //TODO change whats returned
    private STNode strstat()
    {
        //if lookahead is the for keyword which is the start of <forstat> then satisfy the <strstat> ::= <forstat> rule
        if (this.next.getTokenID() == 17) return this.forstat();
        //if lookahead is the if keyword which is the start of <ifstat> then satisfy the <strstat> ::= <ifstat> rule
        if (this.next.getTokenID() == 20) return this.ifstat();
        return new STNode();
    }

    //Rule: NFOR <forstat> ::= for ( <asgnlist> ; <bool> ) <stats> end
    private STNode forstat()
    {
        STNode alist, bool, stats;
        //match & consume for keyword
        this.match(Tokens.TTFOR);
        //match & consume left parentheses for (
        this.match(Tokens.TLPAR);
        //satisfy <asgnlist> rule
        alist = this.asgnlist();
        //match & consume comma
        this.match(Tokens.TCOMA);
        //satisfy <bool> rule
        bool = this.bool();
        //match & consume right parenthses for )
        this.match(Tokens.TRPAR);
        //satisfy <stats> rule
        stats = this.stats();
        //match & consume end keyword
        this.match(Tokens.TTEND);
        //Return a node for NodeValue NFOR, alist as left child, bool as middle child and stats as right child
        return new STNode(NodeValue.NFOR, alist, bool, stats);
    }

    //Rule: NREPT <repstat> ::= repeat ( <asgnlist> ) <stats> until <bool>
    private STNode repstat()
    {
        STNode alist, stats, bool;
        //match & consume repeat keyword
        this.match(Tokens.TREPT);
        //match & consume left parentheses for (
        this.match(Tokens.TLPAR);
        //satisfy <asgnlist> rule
        alist = this.asgnlist();
        //match & consume right parenthses for )
        this.match(Tokens.TRPAR);
        //satisfy <stats> rule
        stats = this.stats();
        //match & consume until keyword
        this.match(Tokens.TUNTL);
        //satisfy <bool> rule
        bool = this.bool();
        //return a node for NodeValue NREPT, alist becomes left child, stats becomes middle and bool becomes right
        return new STNode(NodeValue.NREPT, alist, stats, bool);
    }

    //Original Rule: NASGNS <asgnlist>  ::= <asgnstat> | <asgnstat>, <asgnlist>
    //Left Factored: NASGNS <asignlist> ::= <asgnstat> {epsilon | , <asgnlist>}
    private STNode asgnlist()
    {
        STNode stat ,list;
        stat = this.asgnstat();
        //if we have a comma
        if(this.next.getTokenID() == 32)
        {
            //generate next valid token
            this.nextToken();
            list = this.asgnlist();
            //return a new node with NodeValue NASNS, stat is assigned as the left child and list becomes the right child
            return new STNode(NodeValue.NASGNS, stat, list);
        }
        //epsilon path just return <asgnstat>
        return stat;
    }

    //Rule: Special <asgnstat> ::= <var> <asgnop> <bool>
    //              <asgnop>   ::= = | += | -= | *= | /=
    private STNode asgnstat()
    {
        STNode stat = new STNode(), var, bool;
        //generate node and satisfy <var> rule
        var = this.var();
        //swtich case for <asgnop>
        switch(this.next.getTokenID())
        {
            case 37: stat.setNodeValue(NodeValue.NASGN);
            case 51: stat.setNodeValue(NodeValue.NPLEQ);
            case 52: stat.setNodeValue(NodeValue.NMNEQ);
            case 53: stat.setNodeValue(NodeValue.NSTEQ);
            case 54: stat.setNodeValue(NodeValue.NDVEQ);
            default: this.error("Assignment operator not found");
        }
        //generate node and satisfy <bool> rule
        bool = this.bool();
        //following the diagram from week 5 lecture slide 33
        stat.setLeftChild(var);
        stat.setRightChild(bool);
        return stat;
    }

    //This is the Dangling Else grammar which is a classic example of an ambigious grammar
    //Original Rule: NIFTH  <ifstat> ::= if ( <bool> ) <stats> end
    //               NIIFTE <ifstat> ::= if ( <bool> ) <stats> else <stats> end
    //Left Factored: <ifstat> ::= if ( <bool> ) <stats> <iftail>
    //               <iftail> ::= end | else <stats> end
    private STNode ifstat()
    {
        STNode bool, stats;
        //match & consume if keyword
        this.match(Tokens.TIFTH);
        //match & consume left parentheses for (
        this.match(Tokens.TLPAR);
        //generate node and satisfy <bool> rule
        bool = this.bool();
        //match & consume right parentheses for )
        this.match(Tokens.TRPAR);
        //generate node and satisfy <stats> rule
        stats = this.stats();
        return this.iftail(bool, stats);
    }

    //Rule: <iftail> ::= end | else <stats> end
    //TODO change whats returned
    private STNode iftail(STNode child1, STNode child2)
    {
        //if we have the end keyword
        if(this.next.getTokenID() == 8)
        {
            //generate next valid token
            this.nextToken();
            return new STNode(NodeValue.NIFTH, child1, child2);
        }
        //if we do not have the end keyword check for else keyword
        if(this.next.getTokenID() == 21)
        {
            this.nextToken();
            STNode stats = stats();
            //generate a new node with NodeValue of NIFTE, child1 as left child, child2 as middle child and stats as right child
            STNode iftail = new STNode(NodeValue.NIFTE, child1, child2, stats);
            //match & consume end keyword
            this.match(Tokens.TTEND);
            return iftail;
        }
        return new STNode();
    }

    //Original Rule: NINPUT <iostat> ::= input   <vlist>
    //               NPRINT <iostat> ::= print   <prlist>
    //               NPRLN  <iostat> ::= println <prlist>
    //TODO change whats returned
    private STNode iostat()
    {
        //check for input keyword
        if(this.next.getTokenID() == 22)
        {
            //generate next valid token
            this.nextToken();
            STNode vlist = this.vlist();
            //return a new node with NINPUT as its node value and vlist as its left child
            return new STNode(NodeValue.NINPUT, vlist);
        }
        //check for print or println keyword
        if(this.next.getTokenID() == 23 || this.next.getTokenID() == 24)
        {
            STNode iostat = new STNode();
            //if we have the print keyword then the NodeValue for iostat is NPRINT
            if(this.next.getTokenID() == 23) iostat.setNodeValue(NodeValue.NPRINT);
            //same as above but for println keyword
            if(this.next.getTokenID() == 24) iostat.setNodeValue(NodeValue.NPRLN);
            STNode prlist = this.prlist();
            iostat.setLeftChild(prlist);
            return iostat;
        }
        return new STNode();
    }

    //Original Rule: NCALL <callstat> ::= <id> ( <elist> ) | <id> ()
    //Notes: common start to the rule which is <id> (
    //TODO fix for optional rule
    private STNode callstat()
    {
        //match & consume identifier token for <id>
        this.match(Tokens.TIDEN);
        //match & consume left parantheses token for (
        this.match(Tokens.TLPAR);
        //create a new node for <elist>
        STNode elist = this.elist();
        //match & consume right parentheses for )
        this.match(Tokens.TRPAR);
        return new STNode(NodeValue.NCALL);
    }

    //Original Rule: NRETN <returnstat> ::= return | return <expr>
    //TODO check if I am doing this correctly, possibly only satisfying the return <expr> rule
    private STNode returnstat()
    {
        //match and consume return keyword
        this.match(Tokens.TRETN);
        STNode expr = this.expr();
        //Return a node with the NRETN NodeValue and expr as its left child
        return new STNode(NodeValue.NRETN, expr);
    }

    //Original Rule: NVLIST <vlist> ::= <var> , <vlist> | <var>
    //Left Factored: NVLIST <vlist> ::= <var> {epsilon | , <vlist>}
    private STNode vlist()
    {
        STNode vlist, var;
        var = this.var();
        //if the look ahead token is a coma then we can consume it and make a recusive call for <vlist>
        if(this.next.getTokenID() == 32)
        {
            //generate next valid token
            this.nextToken();
            vlist = this.vlist();
            //var which is <var> will be the left child and vlist which is <vlist> will be the right child
            return new STNode(NodeValue.NVLIST, var, vlist);
        }
        return var;
    }

    //Original Rules: NSIMV <var> ::= <id>
    //                NARRV <var> ::= <id> [ <expr ] . <id>
    private STNode var()
    {
        STNode var, expr;
        //Match & check for identifier token which is the start of the rule, <id>
        this.match(Tokens.TIDEN);
        //check for left bracket; <id> [
        if(this.next.getTokenID() == 33)
        {
            //generate the next valid token
            this.nextToken();
            expr = this.expr();
            //match & check for ] in <expr> ]
            this.match(Tokens.TRBRK);
            //match and check for . which is after the ]
            this.match(Tokens.TDOTT);
            //match & check for identifier token, <id> at the end of the rule
            this.match(Tokens.TIDEN);
            //Rule has been satisifed completely so we set the node value of var to be NARRV
            //expr will be the left child of var
            var = new STNode(NodeValue.NARRV, expr);
            return var;
        }
        //if we dont have the [ after <id> then we just have the NSIMV rule
        var = new STNode(NodeValue.NSIMV);
        return var;
    }

    //Original Rule: NEXPL <elist> ::= <bool> , <elist> | <bool>
    //Left Factored: NEXPL <elist> ::= <bool> {epsilon | , <elist>}
    private STNode elist()
    {
        STNode bool, elist;
        bool = this.bool();
        if(this.next.getTokenID() == 32)
        {
            //our lookahead is a coma so generate next valid token object from our scanner
            this.nextToken();
            //Recusive rule/function call
            elist = this.elist();
            //Return a node with the NodeValue NEXPL, bool as its left child and elist as its right child
            return new STNode(NodeValue.NEXPL, bool, elist);
        }
        //Epsilon path
        return bool;
    }

    //Original Rule:  NBOOL <bool> ::= <bool> <logop> <rel> | <rel>
    //Left Recursion: NBOOL <bool> ::= <rel> <booltail>
    //                      <booltail> ::= <logop> <rel> <booltail> | epsilon
    private STNode bool()
    {
        STNode rel = this.rel();
        return this.booltail(rel);
    }

    //Rule: <booltail> ::= <logop> <rel> <booltail> | epsilon
    private STNode booltail(STNode left)
    {
        STNode parent, right;
        //If we have <logop> then try to satisfy the <rel> <booltail> part of the rule
        if(this.next.getTokenID() == 27 || this.next.getTokenID() == 28 || this.next.getTokenID() == 29)
        {
            NodeValue nv = null;
            //AND
            if(this.next.getTokenID() == 27) nv = NodeValue.NAND;
            //OR
            if(this.next.getTokenID() == 28) nv = NodeValue.NOR;
            //XOR
            if(this.next.getTokenID() == 29) nv = NodeValue.NXOR;
            //Assign the node value above to parent and set its left child to left
            parent = new STNode(nv,left);
            //Generate next valid Token object from the scanner
            this.nextToken();
            //<rel>
            right = rel();
            parent.setRightChild(right);
            //<booltail>
            return this.booltail(parent);
        }
        //Error check/recovery here?
        //epsilon path
        return left;
    }

    //Original Rule: NNOT <rel> ::= not <expr> <relop> <expr> | <expr> <relop> <expr> | <expr>
    //TODO fix
    private STNode rel()
    {
        STNode exprL, relop, exprR;
        //if we have the not keyword
        if(this.next.getTokenID() == 26)
        {
            exprL = this.expr();
            relop = this.relop();
            exprR = this.expr();
            return new STNode(NodeValue.NNOT, exprL, relop, exprR);
        }
        return this.expr();
    }

    //Rules: NEQL <relop> ::= ==
    //       NNEQ <relop> ::= !=
    //       NGRT <relop> ::= >
    //       NGEQ <relop> ::= >=
    //       NLEQ <relop> ::= <=
    //       NLSS <relop> ::= <
    //TODO might need to add a this.nextToken function call
    private STNode relop()
    {
        return switch(this.next.getTokenID())
        {
            case 50 -> new STNode(NodeValue.NEQL);
            case 49 -> new STNode(NodeValue.NNEQ);
            case 45 -> new STNode(NodeValue.NGRT);
            case 48 -> new STNode(NodeValue.NGEQ);
            case 47 -> new STNode(NodeValue.NLEQ);
            case 44 -> new STNode(NodeValue.NLSS);
            default -> new STNode();
        };
    }

    //Original Rule: NADD <expr> ::= <expr> + <term>
    //               NSUB <expr> ::= <expr> - <term>
    //Left Factored: NADD <expr> ::= <term> <exprtail>
    //               NSUB <expr> ::= <term> <exprtail>
    private STNode expr()
    {
        STNode term = this.term();
        //If we do not have a + or - then just <term> rule is returned
        return this.exprtail(term);
    }

    //Rule: <exprtail> ::= + <term> | - <term> | epsilon
    private STNode exprtail(STNode left)
    {
        STNode tail, term;
        //check for +
        if(this.next.getTokenID() == 38)
        {
            this.nextToken();
            term = this.term();
            //node value for NADD
            //term becomes the left child
            tail = new STNode(NodeValue.NADD, term);
            return tail;
        }
        //check for -
        if(this.next.getTokenID() == 39)
        {
            this.nextToken();
            term = this.term();
            //node value for NADD
            //term becomes the left child
            tail = new STNode(NodeValue.NSUB, term);
            return tail;
        }
        //epsilon path
        return left;
    }

    //Combined all three rules into one function
    //Original Rules: NMUL <term> ::= <term> * <fact> | <fact>
    //                NDIV <term> ::= <term> / <fact> | <fact>
    //                NMOD <term> ::= <term> % <fact> | <fact>
    //Lef Factored: NMUL <term> ::= <fact> {epsilon | * <term>}
    //              NDIV <term> ::= <fact> {epsilon | / <term>}
    //              NMOD <term> ::= <fact> {epsilon | % <term>}
    private STNode term()
    {
        STNode term, fact;
        fact = this.fact();
        if(this.next.getTokenID() == 40 || this.next.getTokenID() == 41 || this.next.getTokenID() == 42)
        {
            //generate next valid token
            this.nextToken();
            term = this.term();
            if(this.next.getTokenID() == 40) return new STNode(NodeValue.NMUL, term, fact);
            if(this.next.getTokenID() == 41) return new STNode(NodeValue.NDIV, term, fact);
            if(this.next.getTokenID() == 42) return new STNode(NodeValue.NMOD, term, fact);
        }
        //epsilon path in the left factored rules
        return fact;
    }

    // OR <exponent> came from <fact> ::= <exponent>
    //Original Rule: NPOW <fact> ::= <fact> ^ <exponent> | <exponent>
    //Left Factored: NPOW <fact> ::= <exponent> <facttail>
    private STNode fact()
    {
        STNode exp = this.exponent();
        return this.facttail(exp);
    }

    //Rule: <facttail> ::= ^ <exponent> <facttail> | epsilon
    private STNode facttail(STNode left)
    {
        STNode parent, right;
        if(this.next.getTokenID() == 43)
        {
            //we have found the ^ so generate the next valid token
            this.nextToken();
            parent = new STNode(NodeValue.NPOW, left);
            right = this.exponent();
            parent.setRightChild(right);
            return this.facttail(parent);
        }
        //epsilon path
        return left;
    }

    //Original Rules:
    //  <exponent> ::= <intlit>
    //  <exponent> ::= <reallit>
    //  <exponent> ::= true
    //  <exponent> ::= false
    //  <exponent> ::= ( <bool> )
    //  <exponent> ::= <fncall>
    //  <exponent> ::= <var>
    private STNode exponent()
    {
        //Check for integer literal token
        if(this.next.getTokenID() == 59) return new STNode(NodeValue.NILIT);
        //check for float literal token
        if(this.next.getTokenID() == 60) return new STNode(NodeValue.NFLIT);
        //check for true keyword token
        if(this.next.getTokenID() == 30) return new STNode(NodeValue.NTRUE);
        //check for false keyword token
        if(this.next.getTokenID() == 31) return new STNode(NodeValue.NFALS);
        //check for ( in the ( <bool> ) rule
        if(this.next.getTokenID() == 35)
        {
            this.nextToken();
            return this.bool();
        }
        //check for identifier which is the start of the <fncall> rule
        if(this.next.getTokenID() == 58)
        {
            this.nextToken();
            return this.fncall();
        }
        //if all rules above are not satisfied then satisiy the <var> rule
        return this.var();
    }

    //Original Rule: NFCALL <fncall> ::= <id> ( <elist> ) | <id> ()
    //Left Factored: NFCALL <fncalL> ::= <id> ( <opt> )
    //                      <opt>    ::= <elist> | epsilon
    //TODO need to make <elist> optional
    private STNode fncall()
    {
        STNode elist = null;
        //match & consume identifier token for <id>
        this.match(Tokens.TIDEN);
        //match & consume left parentheses token for (
        this.match(Tokens.TLPAR);
        //generate node and satisfy <elist> rule
        elist = this.elist();
        //match & consume right paranetheses token for )
        this.match(Tokens.TRPAR);
        return new STNode(NodeValue.NFCALL);
    }

    //Original Rule: NPRLST <prlist> ::= <printitem> , <prlist>
    //                      <prlist> ::= <printitem>
    //Left Factored: NPRLST <prlist> ::= <printitem> {epsilon | , <prlist>}
    private STNode prlist()
    {
        STNode item, list;
        item = this.printitem();
        //if we have a coma
        if(this.next.getTokenID() == 32)
        {
            //generate next valid token
            this.nextToken();
            list = this.prlist();
            return new STNode(NodeValue.NPRLST, item, list);
        }
        //epsilon path
        return item;
    }

    //Rules: NSTRG   <printitem> ::= <string>
    //       Special <printitem> ::= <expr>
    private STNode printitem()
    {
        return this.next.getTokenID() == 61 ? new STNode(NodeValue.NSTRG) : this.expr();
    }
    //TODO rework
    private boolean match(Tokens t)
    {
        if(this.next.getTokenID() == t.getID())
        {
            this.nextToken();
            return true;
        }
        else
        {
            this.error(this.next);
            return false;
        }
    }

    //Message style error reporting function
    //TODO rework for error recovery
    private void error(String s)
    {
        String e = "Syntax Error: " + s;
        this.getOutput().addSyntaxError(e);
    }

    //Token based error reporting function
    //TODO rework for error recovery
    private void error(Token t)
    {
        String e = String.format("Line %d, Column %d: %s\n", t.getLineNo(), t.getColNo(), t.getLexeme());
        this.getOutput().addSyntaxError(e);
    }

    //Setters

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The root of the current object is assigned the STNode r
    public void setRoot(STNode r) {this.root = r;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The LexicalScanner object of the current object is assigned the value of ls
    public void setScanner(LexicalScanner ls) {this.scanner = ls;}

    //Normal setter for next
    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The next Token object of the current object is assigned the value of t
    public void setNext(Token t) {this.next = t;}

    //Secondary setter for next in which the LexicalScanner object of the SyntaxTree will generate the next valid token and assign it to next
    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: A new Token object is generated by the LexicalScanner object and assigned to the current objects next
    public void nextToken()
    {
        //While the scanner generates lexically invalid Token objects
        while(this.next.getTokenID() == 62)
        {
            //Send the invalid Token Object to the output controller so we can report the error
            this.output.addLexicalError(this.next);
            //Generate the next Token object from our scanner, if its valid then the loop will end
            this.next = this.scanner.nextToken();
        }
        //Since next does not have an ID of 62 then its a lexically valid Token object so send it to the OutputController
        this.output.addValidToken(this.next);
    }

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The OutputController object of the current SyntaxTree object that is used for errors is assigned the value of oc
    public void setOutput(OutputController oc) {this.output = oc;}

    //Getters

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the root STNode of the current SyntaxTree object
    public STNode getRoot() {return this.root;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the LexicalScanner object of the current SyntaxTree object which is used for tokenizing
    public LexicalScanner getScanner() {return this.scanner;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the Token object which is being used as a look ahead after the grammar has been left factored into a LL(1) grammar
    public Token getNext() {return this.next;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the OutputController of the SyntaxTree that is being used for handling and displaying errors
    public OutputController getOutput() {return this.output;}
}
