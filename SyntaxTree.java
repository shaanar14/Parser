/*
    Project 2
    Author: Shaan Arora, C3236359
    SyntaxTree Class
    An abstract syntax tree data structure to represent the underlying structure of a CD20 program for future phases of compilation.
 */

//TODO add symbol table and error recovery logic
public class SyntaxTree
{
    //Private member variables

    //The root of the syntax tree
    private STNode root;
    //Lexical Scanner object so we can get the next lexeme
    private LexicalScanner scanner;
    //The next Token which is read by lookahead
    private Token next;
    //OutputController object for errors & listings
    private OutputController output;
    //Symbol Table object
    private SymbolTable table;

    //Default Constructor
    public SyntaxTree()
    {
        this.root = new STNode();
        this.scanner = new LexicalScanner();
        this.next = new Token();
        this.output = new OutputController();
        this.table = new SymbolTable();
    }

    //Only want this function to be public as this will just recursively generate the tree for us from the root node down
    //Dont want to return the root node because that exposes the entire tree
    public void generateTree()
    {
        //Generate the first valid token
        this.nextToken();
        //Recursively generate the Abstract Syntax Tree
        this.setRoot(this.program());
    }

    //Preconditions:  The current SyntaxTree object has been declared & intialized and generateTree() has been called
    //Postconditions: Display the AST in pre order notation in the terminal
    public void outputTree()
    {
        assert this.getRoot() != null : "generateTree() needs to be called";
        this.output.outputSyntaxTree(this);
    }

    //Output function for the internal LexicalScanner object
    //Preconditions:  Current SyntaxTree object has been declared & intialized and generateTree() has been called
    //Postconditions: Displays the Token objects generated by the LexicalScanner object to the terminal
    public void outputScanner()
    {
        assert this.getScanner().getStream().size() != 0 : "Please call generateTree()";
        this.output.outputLexicalScanner(this.getScanner());
    }

    //Recursive functions based on the CD20 grammar after it has been left factored and transformed into a LL(1) grammar
    //  Any rules in the grammar that have the node value Special do not create nodes but instead collapse up to the next rule which does have a node value
    //  Anything not wrapped in <> are specific keywords
    //  <id> , <structid> & <typeid> are all identifier Tokens generated by the scanner
    //  <ilit> , <reallit> & <string> are all special Tokens generated by the scanner

    //Preconditions:
    //Postconditions:
    //Rule: NPROG <program> ::= CD20 <id> <global> <funcs> <mainbody>
    private STNode program()
    {
        SymbolEntry p = new SymbolEntry();
        if(this.next.getTokenID() == Tokens.TCD20)
        {
            //Make a new Symbol Entry object capturing the CD20 keyword
            p.setType(Tokens.TCD20);
            //match & consume CD20 keyword token which should be at the start of every CD20 program in a source code file
            //this will return true because this.next is of Tokens CD20
            //  and also generate the next valid Token for our lookahead
            this.match(Tokens.TCD20);
            //check to see if we do have an identifier token after the CD20 keyword which is the program name
            if(this.next.getTokenID() == Tokens.TIDEN)
            {
                //Set the lexeme of our lookahead token to be the attribute of that SymbolEntry object that is capturing the CD20 keyword
                p.setName(this.next.getLexeme());
                //match & consume the identifier token
                //this will return true because our lookahead is of type TIDEN and will generate the next valid Token for our lookahead
                this.match(Tokens.TIDEN);
                //if the creation of the SymbolEntry object for the start CD20 keyword and program name then add to symbol table
                this.table.setProgram(p);
            }
            //Error message
            else this.errorSyntax("Program name expected", new int[]{this.next.getLineNo(), this.next.getColNo()});
        }
        //Error message
        else this.errorSyntax("CD20 keyword expected", new int[]{this.next.getLineNo(), this.next.getColNo()});
        STNode g = this.globals();
        STNode f = this.funcs();
        STNode m = this.mainbody();
        //SymbolTable object.setProgram(p);
        //the node generated by globals()  will be the left child
        //the node generated by funcs()    will be the middle child
        //the node generated by mainbody() will be the right child
        STNode prog = new STNode(NodeValue.NPROG, g, f, m);
        prog.setRecord(p);
        return prog;
    }

    //Rules: NGLOB   <globals> ::= <consts> <types> <arrays>
    //       Special <consts>  ::= constants <initlist> | epsilon
    //       Special <types>   ::= types <typelist> | epsilon
    //       Special <arrays> ::=  arrays <arraydecls> | epsilon
    private STNode globals()
    {
        STNode consts = new STNode(), types = new STNode(), arrays = new STNode();
        //check if lookahead token is constants keyword
        if(this.next.getTokenID() == Tokens.TCNST)
        {
            //consume lookahead
            this.match(Tokens.TCNST);
            //satisfy the rest of the <consts> rule
            consts = this.initlist();
        }
        //check if lookahead token is types keyword
        if(this.next.getTokenID() == Tokens.TTYPS)
        {
            //consume lookahead
            this.match(Tokens.TTYPS);
            types = this.typelist();
        }
        //start of <arrays>
        if(this.next.getTokenID() == Tokens.TARRS)
        {
            //consume lookahead
            this.match(Tokens.TARRS);
            arrays = this.arraydecls();
        }
        //if consts, types and arrays do not have a node value then just return a node for NGLOB without any children
        if(consts.getNodeValue() == null && types.getNodeValue() == null && arrays.getNodeValue()== null)
        {return new STNode(NodeValue.NGLOB);}
        //Return a STNode object with a NodeValue of NGLOB
        //  consts will be the left child
        //  types will be the middle child
        //  arrays will be the right child
        return new STNode(NodeValue.NGLOB, consts, types, arrays);
    }

    //Original Rule: NILIST <initlist> ::= <init> | <init> , <initlist>
    //Left Factored: NILIST <initlist> ::= <init> {epsilon | , <initlist>}
    private STNode initlist()
    {
        STNode tr1, tr2;
        //Only one <init> epsilon path
        tr1 = this.init();
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            this.match(Tokens.TCOMA);
            tr2 = this.initlist();
            return new STNode(NodeValue.NILIST, tr1, tr2);
        }
        return tr1;
    }

    //Rule: NINIT <init> ::= <id> = <expr>
    private STNode init()
    {
        SymbolEntry r = new SymbolEntry();
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            r.setName(this.next.getLexeme());
            r.setLocation(this.next.getLineNo(), this.next.getColNo());
            this.match(Tokens.TIDEN);
        }
        //Consume the equal symbol
        this.match(Tokens.TEQUL);
        STNode expr = this.expr();
        STNode init = new STNode(NodeValue.NINIT, expr);
        init.setRecord(r);
        //TODO test this
        //If the SymbolEntry does not exist in the SymbolTable then mark it as declared and add it to the SymbolTable
        if(this.table.findGlobals(r))
        {
            //Mark that r has been declared
            r.setDeclared(true);
            //Add the record generated for init to the SymbolTable
            this.table.putGlobals(r.getLineNo(), r);
        }
        else{this.errorSemantic(String.format("%s has already been declared", r.getName()), r.getLocation());}
        return init;
    }

    //Original Rule: NTYPEL <typelist> ::=  <type> <typelist> | <type>
    //Left Factored: NTYPEL <typelist> ::=  <type> {epsilon | <typelist>}
    private STNode typelist()
    {
        STNode t1, t2;
        t1 = this.type();
        //if we have the start of the <type> rule which is an identifier token
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            //dont want to generate next valid token because <type> will match and consume the identifier token
            t2 = this.typelist();
            return new STNode(NodeValue.NTYPEL, t1, t2);
        }
        //epsilon path
        return t1;
    }

    //TOOD implement SymbolEntry objects and semantic checks
    //Rules: NRTYPE <type> ::= <stuctid> is <fields> end
    //       NATYPE <type> ::= <typeid>  is arrray [ <expr> ] of <structid>
    private STNode type()
    {
        SymbolEntry r = new SymbolEntry();
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            r.setName(this.next.getLexeme());
            r.setLocation(this.next.getLineNo(),this.next.getColNo());
            //match identifier token, this is for both <structid> and <typeid> as they are both identifiers
            this.match(Tokens.TIDEN);
        }
        else
        {
            this.errorSyntax("variable expected", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //match is keyword
        if(!this.match(Tokens.TTTIS))
        {
            this.errorSyntax("is keyword expected", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        STNode type = new STNode();
        //for second rule where we have is arrays
        if(this.next.getTokenID() == Tokens.TARAY)
        {
            r.setType(Tokens.TARAY);
            //if the token object is arrays then generate the next valid token object from the scanner
            this.match(Tokens.TARAY);
            //match left square bracket
            this.match(Tokens.TLBRK);
            //Set the left child of type to be the STNode object returned by expr()
            type.setLeftChild(this.expr());
            //match right square bracket
            this.match(Tokens.TRBRK);
            //match of keyword
            this.match(Tokens.TTTOF);
            //match identifier token for <structid>
            if(this.next.getTokenID() == Tokens.TIDEN)
            {
                //r.addToAttribute(this.next.getLexeme());
                //TODO semantic check if its declared
                this.match(Tokens.TIDEN);
            }
            else
            {
                this.errorSyntax("variable expected", new int[]{this.next.getLineNo(), this.next.getColNo()});
                this.nextToken();
            }
            type.setNodeValue(NodeValue.NATYPE);
        }
        else
        {
            //if this.next is not arrays then we have the first rule
            STNode f = this.fields();
            //TODO add attributes
            type.setLeftChild(f);
            if(!this.match(Tokens.TTEND))
            {
                this.errorSyntax("end keyword expect", r.getLocation());
            }
            type.setNodeValue(NodeValue.NRTYPE);
        }
        type.setRecord(r);
        return type;
    }

    //Left Factored like initlist
    //Original Rule: NALIST <arrdecls> ::= <arrdecl> , <arrdecls> | <arrdecl>
    //Left Factored: NALIST <arrdecls> ::= <arrdecl> {epsilon | , <arrdecls>}
    private STNode arraydecls()
    {
        STNode a1, a2;
        a1 = arrdecl();
        //Check for coma
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            this.match(Tokens.TCOMA);
            a2 = arraydecls();
            //NALIST
            return new STNode(NodeValue.NALIST, a1, a2);
        }
        //Only one <arrdecl> present so epsilon path
        //make node generated by <arrdecl> the left child
        return new STNode(NodeValue.NALIST, a1);
    }

    //Rule: NARRD <arrdecl> ::= <id> : <typeid>
    private STNode arrdecl()
    {
        SymbolEntry array = new SymbolEntry();
        //match & consume identifier token for <id>
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            //TODO semantic check on lookahead
            array.setName(this.next.getLexeme());
            array.setType(Tokens.TARAY);
            array.setLocation(this.next.getLineNo(), this.next.getColNo());
            this.match(Tokens.TIDEN);
        }
        else {this.errorSyntax("Identifier required", new int[]{this.next.getLineNo(), this.next.getColNo()});}
        //match & consume identifier token for :
        if(!this.match(Tokens.TCOLN))
        {
            this.errorSyntax("colon required", new int[]{this.next.getLineNo(), this.next.getColNo()});
        }
        //match & consume identifier token for <typeid>
        //TODO semantic check to make sure that <typeid> has been declared already
        if(!this.match(Tokens.TIDEN))
        {
            this.errorSyntax("Identifier required", new int[]{this.next.getLineNo(), this.next.getColNo()});
        }
        //if the entry does not exist in the table
        if(this.table.findGlobals(array))
        {
            array.setDeclared(true);
            //Add the array SymbolEntry into globals in the SymbolTable
            this.table.putGlobals(array.getLineNo(), array);
        }
        //Error message
        else{this.errorSemantic(String.format("%s has already been decalred", array.getName()), array.getLocation());}
        //Return a new node with a value of NARRD and array as its record
        return new STNode(NodeValue.NARRD, array);
    }

    //Rule: NMAIN  <mainbody> ::= main <slist> begin <stats> end CD20 <id>
    private STNode mainbody()
    {
        //match main keyword
        if(!this.match(Tokens.TMAIN))
        {
            this.errorSyntax("end keyword missing",new int[]{this.next.getLineNo(), this.next.getColNo()});
        }
        STNode slist = this.slist();
        //match begin keyword
        if(!this.match(Tokens.TBEGN))
        {
            this.errorSyntax("end keyword missing",new int[]{this.next.getLineNo(), this.next.getColNo()});
        }
        STNode stats = this.stats();
        //match end keyword
        if(this.next.getTokenID() == Tokens.TTEND) this.match(Tokens.TTEND);
        else this.errorSyntax("end keyword missing",new int[]{this.next.getLineNo(), this.next.getColNo()});
        //TODO Semantics; check if the follow TCD20 TIDEN matchs the SymbolEntry object program in SymbolTable
        //match CD20 keyword
        if(this.next.getTokenID() == Tokens.TCD20)
        {
            //match & consume lookahead token
            this.match(Tokens.TCD20);
            if(this.next.getTokenID() == Tokens.TIDEN)
            {
                //Semantic Check to ensure that program name matches
                if(!this.getTable().getProgramName().equals(this.next.getLexeme()))
                {
                    //TODO tidy up?
                    //trim to remove whitespace makes error message in listing file look nicer
                    this.errorSemantic(String.format("Program name does not match, expected \"%s\"", this.getTable().getProgramName().trim())
                                       , new int[] {this.next.getLineNo(), this.next.getColNo()});
                }
                //if the program names do match then we can just consume our lookehead
                else this.match(Tokens.TIDEN);
            }
            //Error message
            else this.errorSyntax("Program name expected", new int[]{this.next.getLineNo(), this.next.getColNo()});
        }
        //Error message
        else this.errorSyntax("CD20 keyword expected", new int[]{this.next.getLineNo(), this.next.getColNo()});
        //Return a STNode object with the NodeValue NMAIN, slist as its left child & stats as its right child
        return new STNode(NodeValue.NMAIN, slist, stats);
    }

    //Original Rule: NSDLST <slist> ::= epsilon | <sdecl> , <slist> | <sdecl>
    //Left Factored: NSDLST <slist> ::= <sdecl> {epsilon| , <slist>}
    private STNode slist()
    {
        STNode sdecl, slist;
        SymbolEntry s = new SymbolEntry();
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            //dont want to call this.nextToken() or this.match() because sdecl() will consume the lookahead
            sdecl = this.sdecl();
            //check to see if we have a comma
            if(this.next.getTokenID() == Tokens.TCOMA)
            {
                //match & consume the comma
                this.match(Tokens.TCOMA);
                slist = this.slist();
                return new STNode(NodeValue.NSDLST, sdecl, slist) ;
            }
            return sdecl;
        }
        //<slist> ::= epsilon
        return new STNode(NodeValue.NSDLST);
    }

    //Rule: NSDECL <sdecl> ::= <id> : int | <id> : real | <id> : bool
    //TODO change whats returned
    private STNode sdecl()
    {
        SymbolEntry r = new SymbolEntry();
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            r.setName(this.next.getLexeme());
            r.setLocation(this.next.getLineNo(), this.next.getColNo());
            //match identifier token for <id>
            this.match(Tokens.TIDEN);
        }
        else{this.errorSyntax("variable not found",new int[]{this.next.getLineNo(), this.next.getColNo()});}
        this.match(Tokens.TCOLN);
        if(this.next.getTokenID() == Tokens.TINTG || this.next.getTokenID() == Tokens.TREAL || this.next.getTokenID() == Tokens.TBOOL)
        {
            r.setType(this.next.getTokenID());
            this.match(this.next.getTokenID());
            return new STNode(NodeValue.NSDECL, r);
        }
        this.errorSyntax("int or real or bool keyword not found", new int[]{this.next.getLineNo(), this.next.getColNo()});
        return new STNode();
    }

    //Original Rule: NFLIST <fields> ::= <sdecl> , <fields> | <sdecl>
    //Left Factored: NFLIST <fields> ::= <sdecl> {epsilon | , <fields>}
    private STNode fields()
    {
        STNode f1, f2;
        f1 = this.sdecl();
        //check for coma for , <fields>
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //generate next valid token object from the scanner
            this.match(Tokens.TCOMA);
            f2 = this.fields();
            return new STNode(NodeValue.NFLIST, f1, f2);
        }
        //Epsilon path
        return f1;
    }

    //Original Rule: NFUNCS <funcs> ::= epsilon | <func> <funcs>  | <func>
    //Left Factored: NFUNCS <funcs> ::= epsilon | <func> {epsilon | <funcs>}
    private STNode funcs()
    {
        STNode func, funcs;
        //if we see another func keyword recursive call
        if(this.next.getTokenID() == Tokens.TFUNC)
        {
            //func() will match and consume the func keyword that we saw before we entered this function
            func = this.func();
            funcs = this.funcs();
            return new STNode(NodeValue.NFUNCS, func, funcs);
        }
        //<funcs> ::= epsilon path
        return new STNode(NodeValue.NFUNCS);
    }

    //Original Rule: NFUND   <func>     ::= func <id> ( <plist> ) : <rytpe> <funcbody>
    //               Special <plist>    ::= <params> | epsilon
    //               Special <rtype>    ::= <stype> | void
    //               Special <stype>    ::= int | real | bool
    //               Special <funcbody> ::= <locals> begin <stats> end
    //               Special <locals>   ::= <dlist> | epsilon
    private STNode func()
    {
        STNode params = new STNode(), dlist = new STNode(), stats;
        //match & consume func keyword
        //which will return true because the only way we can enter this function is the if statement in funcs()
        if(this.next.getTokenID() == Tokens.TFUNC)
        {
            //generate a new table in the SymbolTable
            this.table.createNewScope();
            this.match(Tokens.TFUNC);
        }
        //match identifier token for <id>
        this.match(Tokens.TIDEN);
        //match left parantheses token for (
        this.match(Tokens.TLPAR);
        //if we have the start of <params> which goes to <param> which starts with either <id> or const keyword
        //if we dont have the start of the <params> rule then thats okay because <plist> ::= epsilon
        if(this.next.getTokenID() == Tokens.TIDEN || this.next.getTokenID() == Tokens.TCONS) params = this.params();
        //match right parantheses token for )
        this.match(Tokens.TRPAR);
        //match colon token for :
        this.match(Tokens.TCOLN);
        //check for int or real or bool or void for <rtype>
        if(this.next.getTokenID() == Tokens.TVOID ||
           this.next.getTokenID() == Tokens.TINTG ||
           this.next.getTokenID() == Tokens.TREAL ||
           this.next.getTokenID() == Tokens.TBOOL)
        {
            //capture the keyword in a SymbolEntry
            //generate next valid token
            this.match(this.next.getTokenID());
            //All this below is for <funcbody>
            //check for the start of the rule <dlist> which is an identifier token
            //dlist is derived from <locals>
            if(this.next.getTokenID() == Tokens.TIDEN) dlist = dlist();
            //match & consume begin keyword which will also generate the next valid token if successsful
            this.match(Tokens.TBEGN);
            //<stats> in <funcbody>
            stats = this.stats();
            //match & consume end keyword
            this.match(Tokens.TTEND);
            //Return a STNode object with the NodeValue NFUND
            //  params will be the left child but could be an empty node since  <plist>  ::= epsilon
            //  dlist will be the middle child but could be an empty node since <locals> ::= epsilon
            //  stats will be the right child which cannot be an empty node
            //TODO semantic check that this function does indeed have a return statement
            return new STNode(NodeValue.NFUND, params, dlist, stats);
        }
        this.errorSyntax("int or real or bool or void not found", new int[]{this.next.getLineNo(),this.next.getColNo()});
        return new STNode();
    }

    //Original Rule: NPLIST  <params> ::= <param> , <params>
    //               Special <params> ::= <param>
    //Left Factored: NPLIST  <params> ::= <param> {epsilon | , <params>}
    private STNode params()
    {
        STNode param, params;
        param = this.param();
        //check to see if we have a coma for , <params>
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //generate next valid token
            this.nextToken();
            params = this.params();
            return new STNode(NodeValue.NPLIST, param, params);
        }
        //epsilon path
        return param;
    }

    //Rules: NSIMP <param> ::= <sdecl>
    //       NARRP <param> ::= <arrdecl>
    //       NARRC <param> ::= const <arrdecl>
    private STNode param()
    {
        SymbolEntry p = new SymbolEntry();
        STNode sdecl, arrdecl;
        //check for const keyword for the rule const <arrdecl>
        if(this.next.getTokenID() == Tokens.TCONS)
        {
            //this.next wont have a lexeme so add it manually
            p.setName("const");
            //match and consume our lookahead
            this.match(Tokens.TCONS);
            arrdecl = this.arrdecl();
            //Return a node for NodeValue NARCC with arrdecl as left child
            STNode t = new STNode(NodeValue.NARRC, arrdecl);
            t.setRecord(p);
            return t;
        }
        //check for <id> which is the start of both <sdecl> & <arrdecl>
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            p.setName(this.next.getLexeme());
            //match for identifier which is the start of both rules
            this.match(Tokens.TIDEN);
        }
        else {this.errorSyntax("identifier expect",new int[]{this.next.getLineNo(), this.next.getColNo()});}
        //check for : after <id> in both <sdecl> & <arrdecl>
        if(this.next.getTokenID() == Tokens.TCOLN)
        {
            //since next is wont have a lexeme we just add the colon in manually
            //p.addToAttribute(":");
            this.match(Tokens.TCOLN);
        }
        else {this.errorSyntax("colon expected", new int[]{this.next.getLineNo(), this.next.getColNo()});}
        //if our lookahead is an identifier token then we can satisfy the  rule <arrdecl>
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            //p.addToAttribute(this.next.getLexeme());
            //consume identifier
            this.match(Tokens.TIDEN);
            //<param> ::= <arrdecl>
            arrdecl = new STNode(NodeValue.NARRD);
            arrdecl.setRecord(p);
            return new STNode(NodeValue.NARRP, arrdecl);
        }
        //check for keyword after <id> in <sdecl>
        if(this.next.getTokenID() == Tokens.TINTG || this.next.getTokenID() == Tokens.TREAL || this.next.getTokenID() == Tokens.TBOOL)
        {
            //set the type of the SymbolEntry to be the keyword
            p.setType(this.next.getTokenID());
            //match and consume the keyword
            this.match(this.next.getTokenID());
            sdecl = new STNode(NodeValue.NSDECL, p);
            return new STNode(NodeValue.NSIMP, sdecl);
        }
        this.errorSyntax("identifier or keyword expected", new int[]{this.next.getLineNo(), this.next.getColNo()});
        return new STNode();
    }

    //Original Rule: NDLIST  <dlist> ::= <decl> , <dlist>
    //               Special <dlist> ::= <decl>
    //               Special <decl>  ::= <sdecl> | <arrdecl>
    //Left Factored: NDLSIT  <dlist> ::= <sdecl> | <arrdecl> {epsilon | , <dlist>}
    private STNode dlist()
    {
        SymbolEntry r = new SymbolEntry();
        STNode decl = new STNode(), dlist;
        //<sdecl> & <arrdecl> both start with <id> so match & consume that
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            r.setName(this.next.getLexeme());
            this.match(Tokens.TIDEN);
        }
        else {this.errorSyntax("identifier expect", new int[]{this.next.getLineNo(), this.next.getColNo()});}
        //check for : after <id> in both <sdecl> & <arrdecl>
        if(this.next.getTokenID() == Tokens.TCOLN)
        {
            //since next is wont have a lexeme we just add the colon in manually
            //r.addToAttribute(":");
            this.match(Tokens.TCOLN);
        }
        //check for <sdecl>
        if(this.next.getTokenID() == Tokens.TINTG || this.next.getTokenID() == Tokens.TREAL || this.next.getTokenID() == Tokens.TBOOL)
        {
            //match & consume keyword
            this.match(this.next.getTokenID());
            decl = new STNode(NodeValue.NSDECL);
            decl.setRecord(r);
        }
        //check for <arrdecl>
        else if(this.next.getTokenID() == Tokens.TIDEN)
        {
            //add the lexeme of our lookahead token to our SymbolEntry
            r.setName(this.next.getLexeme());
            //match & consume our lookahead token
            this.match(Tokens.TIDEN);
            decl = new STNode(NodeValue.NARRD);
            decl.setRecord(r);
        }
        //check if lookahead is , if it is then we can satisfy , <dlist>
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //lookahead doesn't have a lexeme for TCOMA so add the comma to the record manually
            //r.addToAttribute(",");
            //match & consume our lookahead
            this.match(Tokens.TCOMA);
            decl.setRecord(r);
            dlist = this.dlist();
            return new STNode(NodeValue.NDLIST, decl, dlist);
        }
        //epsilon path
        return decl;
    }

    //Original rules: NSTATS  <stats>   ::= <stat> ; <stats> | <strstat> <stats>
    //                Special <stats>   ::= <stat> ;  | <strstat>
    //                Special <strstat> ::= <forstat> | <ifstat>
    //                Special <stat>    ::= <repstat> | <asgnstat> | <iostat> | <callstat> | <returnstat>
    //Left Factored:  NSTATS  <stats>   ::= <stat> ;  | <strstat> {epsilon | <stats>}
    private STNode stats()
    {
        //stat1 for <stat> and stat2 for <strstat> and stats for recursive call
        STNode stat = new STNode(), str = new STNode(), stats;
        //deciding between <stat> ; and <strstat> based on if the lookahead token matches the start of these rules
        switch(this.next.getTokenID())
        {
            //case for <stat> ::= <repstat>
            //check if lookahead token is repeat keyword which is the start of <repstat>
            case TREPT:
                stat = this.repstat();
                //check for ; after <stat>
                if(!this.match(Tokens.TSEMI))
                {
                    this.errorSyntax("semi colon is missing", stat.getRecord().getLocation());
                }
                if(this.next.getTokenID() == Tokens.TTEND) return stat;
                //recursive call
                stats = this.stats();
                //the node generated by the recursive rule/function call becomes the left child
                return new STNode(NodeValue.NSTATS, stat, stats);
            //case for <stat> ::= <iostat>
            //check if lookahead token is input or print or println keyword which is the start of <iostat>
            case TINPT:
            case TPRIN:
            case TPRLN:
                stat = this.iostat();
                //check for ; after <stat>
                if(!this.match(Tokens.TSEMI))
                {
                    this.errorSyntax("semi colon is missing", stat.getRecord().getLocation());
                }
                if(this.next.getTokenID() == Tokens.TTEND || this.next.getTokenID() == Tokens.TCD20) return stat;
                //recursive call/recursive rule
                stats = this.stats();
                //the node generated by the recursive rule/function call becomes the left child
                return new STNode(NodeValue.NSTATS, stat, stats);
            //case for <stat> ::= <asgnstat> | <callstat>
            //since both of these rules start with <id> we need to decide which rule to follow
            case TIDEN:
                stat = this.decideStat();
                //check for ; after <stat>
                if(!this.match(Tokens.TSEMI))
                {
                    this.errorSyntax("semi colon is missing", stat.getRecord().getLocation());
                }
                if(this.next.getTokenID() == Tokens.TTEND) return new STNode(NodeValue.NSTATS, stat);
                //recursive call
                stats = this.stats();
                //the node generated by the recursive call becomes the left child of the STNode being returned
                return new STNode(NodeValue.NSTATS, stat, stats);
            //case for <stat> ::= <returnstat>
            //check if lookahead token is return keyword which is the start of <returnstat>
            case TRETN:
                stat = this.returnstat();
                //match & consume ; after <stat>
                if(!this.match(Tokens.TSEMI))
                {
                    this.errorSyntax("semi colon is missing", stat.getRecord().getLocation());
                }
                if(this.next.getTokenID() == Tokens.TTEND) return stat;
                //recursive call
                stats = this.stats();
                //the node generated by the recursive rule/function call becomes the left child
                return new STNode(NodeValue.NSTATS, stat, stats);
            //case for <strstat> ::= <forstat>
            //check if lookahead token is for keyword which is the start of <forstat>
            case TTFOR:
                str = this.forstat();
                //recursive call
                stats = this.stats();
                //the node generated by the recursive rule/function call becomes the left child
                return new STNode(NodeValue.NSTATS, str, stats);
            //case for <strstat> ::= <ifstat>
            //check if lookahead token is if keyword which is the start of <ifstat>
            case TIFTH:
                str = this.ifstat();
                if(this.next.getTokenID() == Tokens.TTEND) return new STNode(NodeValue.NSTATS, str);
                //recursive call
                stats = this.stats();
                return new STNode(NodeValue.NSTATS, str, stats);
            //epsilon in {epsilon | <stats>}
            //any nodes generated by stat() will become the left child and any nodes generated by str() will become the rigth child
            default: return new STNode(NodeValue.NSTATS, stat, str);
        }
    }

    //Helper function to decide between <asgnstat> and <callstat> in the rule <stat> ::= <asgnstat> | <callstat>
    // since they both start with <id>
    //Rules: Special <stat>     ::= <asgnstat> | <callstat>
    //       Special <asgnstat> ::= <var> <asgnop> <bool>
    //       NSIMV   <var>      ::= <id>
    //       Special <var>      ::= <id> [ <expr> ] . <id>
    //       NCALL   <callstat> ::= <id> ( <elist> ) | <id> ()
    private STNode decideStat()
    {
        SymbolEntry r = new SymbolEntry();
        //the lookahead is the of type TIDEN because that is how we entered this function in stats()
        //so we can match and consume that lookahead
        //could also use this.next.getTokenID() instead of Tokens.TIDEN
        r.setName(this.next.getLexeme());
        r.setLocation(this.next.getLineNo(), this.next.getColNo());
        this.match(Tokens.TIDEN);
        //Cases for <stat> ::= <asgnstat>
        //check for the start of the rule <asgnop> which means that we have NSIMV <var> ::= <id>
        if(this.next.getTokenID() == Tokens.TEQUL || this.next.getTokenID() == Tokens.TPLEQ ||
           this.next.getTokenID() == Tokens.TMNEQ || this.next.getTokenID() == Tokens.TSTEQ || this.next.getTokenID() == Tokens.TDVEQ)
        {
            r.setType(this.next.getTokenID());
            //satisfy <asgnop>
            STNode a = this.asgnop();
            //satisfy <bool>
            STNode b = this.bool();
            //since we just have <var> ::= <id> make a node for NSIMV
            STNode v = new STNode(NodeValue.NSIMV);
            v.setRecord(r);
            //following the output diagram from the specs we will return a
            //with v as its left child and b as its right child
            a.setLeftChild(v);
            a.setRightChild(b);
            return a;
        }
        //we have consumed a <id> so now check for [ in NARRV <var> ::= <id> [ <expr> ] . <id>
        if(this.next.getTokenID() == Tokens.TLBRK)
        {
            //consume our lookahead
            this.match(Tokens.TLBRK);
            STNode e = this.expr();
            //match the ] after <expr>
            this.match(Tokens.TRBRK);
            //then match the . after ]
            this.match(Tokens.TDOTT);
            //now match for <id> at the end
            this.match(Tokens.TIDEN);
            //<var> ::= <id> [ <expr> ] . <id> has been satisfied
            STNode v = new STNode(NodeValue.NARRV);
            v.setRecord(r);
            //make the NARRV <var> node the left child of the <expr> node
            e.setLeftChild(v);
            //this for <asgnstat> ::= <var> <asgnop> <bool>
            STNode a = this.asgnop();
            STNode b = this.bool();
            //same as above, e becomes left child and b becomes right child
            a.setLeftChild(e);
            a.setRightChild(b);
            return a;
        }
        //Case NCALL <callstat> ::= <id> ( <elist> ) | <id> ()
        if(this.next.getTokenID() == Tokens.TLPAR)
        {
            //consume the ( after <id>
            this.match(Tokens.TLPAR);
            //check for ) after <id> in <callstat> ::= <id> ()
            if(this.next.getTokenID() == Tokens.TRPAR)
            {
                this.match(Tokens.TRPAR);
                return new STNode(NodeValue.NCALL);
            }
            //satisfy <id> ( <elist>
            STNode e = this.elist();
            //match and consume the ) after <elist>
            this.match(Tokens.TRPAR);
            //return a node for NCALL with the node generated by elist() as its left child
            STNode call = new STNode(NodeValue.NCALL, e);
            call.setRecord(r);
            return call;
        }
        this.errorSyntax("incomplete statement", r.getLocation());
        STNode s = new STNode();
        s.setRecord(r);
        return s;
    }

    //Rule: NFOR <forstat> ::= for ( <asgnlist> ; <bool> ) <stats> end
    private STNode forstat()
    {
        STNode alist, bool, stats;
        //match & consume for keyword
        if(!this.match(Tokens.TTFOR))
        {
            this.errorSyntax("for keyword missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //match & consume left parentheses for (
        if(!this.match(Tokens.TLPAR))
        {
            this.errorSyntax("( is missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //satisfy <asgnlist> rule
        alist = this.asgnlist();
        //match & consume semi colon inbetween <asgnlist> & <bool>
        if(!this.match(Tokens.TSEMI))
        {
            this.errorSyntax("; is missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //satisfy <bool> rule
        bool = this.bool();
        //match & consume right parenthses for )
        if(!this.match(Tokens.TRPAR))
        {
            this.errorSyntax(") is missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //satisfy <stats> rule
        stats = this.stats();
        //match & consume end keyword
        if(!this.match(Tokens.TTEND))
        {
            this.errorSyntax("end keyword missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //Return a node for NodeValue NFOR, alist as left child, bool as middle child and stats as right child
        return new STNode(NodeValue.NFOR, alist, bool, stats);
    }

    //Rule: NREPT <repstat> ::= repeat ( <asgnlist> ) <stats> until <bool>
    private STNode repstat()
    {
        STNode alist, stats, bool;
        //match & consume repeat keyword
        if(!this.match(Tokens.TREPT))
        {
            this.errorSyntax("repeat keyword missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //match & consume left parentheses for (
        if(!this.match(Tokens.TLPAR))
        {
            this.errorSyntax("( is missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //satisfy <asgnlist> rule
        alist = this.asgnlist();
        //match & consume right parenthses for )
        if(!this.match(Tokens.TRPAR))
        {
            this.errorSyntax(") is missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //satisfy <stats> rule
        stats = this.stats();
        //match & consume until keyword
        if(!this.match(Tokens.TUNTL))
        {
            this.errorSyntax("until keyword is missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //satisfy <bool> rule
        bool = this.bool();
        //return a node for NodeValue NREPT, alist becomes left child, stats becomes middle and bool becomes right
        return new STNode(NodeValue.NREPT, alist, stats, bool);
    }

    //Original Rule: NASGNS              <asgnlist> ::= <asgnstat> | <asgnstat>, <asgnlist>
    //               Special             <asgnstat> ::= <var> <asgnop> <bool>
    //               Multiple NodeValues <asgnop>   ::= = | += | -= | *= | /=
    //Left Factored: NASGNS              <asignlist> ::= <asgnstat> {epsilon | , <asgnlist>}
    //
    private STNode asgnlist()
    {
        //var for <var>, a for <asgnop>, bool for <bool>
        //stat for <asgnstat> and list for <asgnlist>
        STNode var = new STNode(), a = new STNode(), bool = new STNode(), stat ,list;
        //check for start of <asgnstat> rule which means to check for the start of <var>
        // which is <id>
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            //not generating next valid token because
            //var() will match and consume the lookahead which is an identifier token
            //capture node generated by <var>
            var = this.var();
            //capture node generated by <asgnop>
            a = this.asgnop();
            //capture node generated by <bool>
            bool = this.bool();
        }
        stat = new STNode(NodeValue.NASGNS, var, a, bool);
        //if we have a comma
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //generate next valid token
            this.match(Tokens.TCOMA);
            //capture node generated by recursive rule/call <asgnlist>
            list = this.asgnlist();
            //return a new node with NodeValue NASNS, stat is assigned as the left child and list becomes the right child
            return new STNode(NodeValue.NASGNS, stat, list);
        }
        //epsilon path in {epsilon | , <asgnlist>}
        return stat;
    }

    //Rules: NASGN <asgnop> ::= =
    //       NPLEQ <asgnop> ::= +=
    //       NMNEQ <asgnop> ::= -=
    //       NSTEQ <asgnop> ::= *=
    //       NDVEQ <asgnop> ::= /=
    private STNode asgnop()
    {
        STNode a = new STNode();
        switch (this.next.getTokenID())
        {
            //match & consume if we have a = for <asgnop> ::= =
            case TEQUL:
                this.match(Tokens.TEQUL);
                a.setNodeValue(NodeValue.NASGN);
                break;
            //match & consume if we have a += for <asgnop> ::= +=
            case TPLEQ:
                this.match(Tokens.TPLEQ);
                a.setNodeValue(NodeValue.NPLEQ);
                break;
            //match & consume if we have a -= for <asgnop> ::= -=
            case TMNEQ:
                this.match(Tokens.TMNEQ);
                a.setNodeValue(NodeValue.NMNEQ);
                break;
            //match & consume if we have a *= for <asgnop> ::= *=
            case TSTEQ:
                this.match(Tokens.TSTEQ);
                a.setNodeValue(NodeValue.NSTEQ);
                break;
            //match & consume if we have a /= for <asgnop> ::= /=
            case TDVEQ:
                this.match(Tokens.TDVEQ);
                a.setNodeValue(NodeValue.NDVEQ);
                break;
            default:
                this.errorSyntax("assignment operator missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
                this.nextToken();
                break;
        }
        return a;
    }

    //This is the Dangling Else grammar which is a classic example of an ambigious grammar
    //Original Rule: NIFTH  <ifstat> ::= if ( <bool> ) <stats> end
    //               NIIFTE <ifstat> ::= if ( <bool> ) <stats> else <stats> end
    //Left Factored: <ifstat> ::= if ( <bool> ) <stats> <iftail>
    //               <iftail> ::= end | else <stats> end
    private STNode ifstat()
    {
        STNode bool, stats;
        //match & consume if keyword
        if(this.next.getTokenID() == Tokens.TIFTH)
        {
            this.match(Tokens.TIFTH);
        }
        else
        {
            this.errorSyntax("if keyword missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //match & consume left parentheses for (
        if(this.next.getTokenID() == Tokens.TLPAR)
        {
            this.match(Tokens.TLPAR);
        }
        else
        {
            this.errorSyntax("( missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //generate node and satisfy <bool> rule
        bool = this.bool();
        //match & consume right parentheses for )
        if(this.next.getTokenID() == Tokens.TRPAR)
        {
            this.match(Tokens.TRPAR);
        }
        else
        {
            this.errorSyntax("( missing", new int[]{this.next.getLineNo(), this.next.getColNo()});
            this.nextToken();
        }
        //generate node and satisfy <stats> rule
        stats = this.stats();
        return this.iftail(bool, stats);
    }

    //Rule: <iftail> ::= end | else <stats> end
    //TODO change whats returned
    private STNode iftail(STNode child1, STNode child2)
    {
        STNode iftail = new STNode();
        //if we have the end keyword
        if(this.next.getTokenID() == Tokens.TTEND)
        {
            //generate next valid token
            this.match(Tokens.TTEND);
            iftail.setNodeValue(NodeValue.NIFTH);
            iftail.setLeftChild(child1);
            iftail.setRightChild(child2);
            return iftail;
        }
        //if we do not have the end keyword check for else keyword
        if(this.next.getTokenID() == Tokens.TELSE)
        {
            //consume lookahead
            this.match(Tokens.TELSE);
            STNode stats = stats();
            //generate a new node with NodeValue of NIFTE, child1 as left child, child2 as middle child and stats as right child
            iftail.setNodeValue(NodeValue.NIFTE);
            iftail.setLeftChild(child1);
            iftail.setMiddleChild(child2);
            iftail.setRightChild(stats);
            //match & consume end keyword
            this.match(Tokens.TTEND);
            return iftail;
        }
        //if all else fails an empty node is returned
        return iftail;
    }

    //Original Rule: NINPUT <iostat> ::= input   <vlist>
    //               NPRINT <iostat> ::= print   <prlist>
    //               NPRLN  <iostat> ::= println <prlist>
    private STNode iostat()
    {
        STNode iostat = new STNode();
        SymbolEntry i = new SymbolEntry();
        //check for input keyword
        if(this.next.getTokenID() == Tokens.TINPT)
        {
            i.setType(this.next.getTokenID());
            i.setLocation(this.next.getLineNo(), this.next.getColNo());
            //match & consume lookahead
            this.match(Tokens.TINPT);
            //satisfy the rule input <vlist>
            STNode vlist = this.vlist();
            //return a node with NINPUT node value and vlist as its left child
            iostat = new STNode(NodeValue.NINPUT, vlist);
            iostat.setRecord(i);
            //return a new node with NINPUT as its node value and vlist as its left child
            //if none of the keywords are there an empty node is returned
            return iostat;
        }
        //check for print or println keyword
        if(this.next.getTokenID() == Tokens.TPRIN || this.next.getTokenID() == Tokens.TPRLN)
        {
            i.setType(this.next.getTokenID());
            i.setLocation(this.next.getLineNo(), this.next.getColNo());
            //if we have the print keyword then the NodeValue for iostat is NPRINT
            if(this.next.getTokenID() == Tokens.TPRIN)
            {
                this.match(Tokens.TPRIN);
                iostat.setNodeValue(NodeValue.NPRINT);
            }
            //same as above but for println keyword
            if(this.next.getTokenID() == Tokens.TPRLN)
            {
                this.match(Tokens.TPRLN);
                iostat.setNodeValue(NodeValue.NPRLN);
            }
            STNode prlist = this.prlist();
            iostat.setLeftChild(prlist);
            iostat.setRecord(i);
            iostat.setRecord(i);
            //if none of the keywords are there an empty node is returned
            return iostat;
        }
        return iostat;
    }

    //Rule: NRETN <returnstat> ::= return | return <expr>
    private STNode returnstat()
    {
        SymbolEntry r = new SymbolEntry();
        r.setType(Tokens.TRETN);
        r.setLocation(this.next.getLineNo(), this.next.getColNo());
        //match and consume return keyword
        this.match(Tokens.TRETN);
        STNode t = new STNode(NodeValue.NRETN);
        t.setRecord(r);
        if(this.next.getTokenID() == Tokens.TSEMI)
        {
            return t;
        }
        STNode expr = this.expr();
        t.setLeftChild(expr);
        //Return a node with the NRETN NodeValue and expr as its left child
        return t;
    }

    //Original Rule: NVLIST <vlist> ::= <var> , <vlist> | <var>
    //Left Factored: NVLIST <vlist> ::= <var> {epsilon | , <vlist>}
    private STNode vlist()
    {
        STNode vlist, var;
        var = this.var();
        //if the look ahead token is a coma then we can consume it and make a recusive call for <vlist>
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //generate next valid token
            this.match(Tokens.TCOMA);
            vlist = this.vlist();
            //var which is <var> will be the left child and vlist which is <vlist> will be the right child
            return new STNode(NodeValue.NVLIST, var, vlist);
        }
        return var;
    }

    //Original Rules: NSIMV <var> ::= <id>
    //                NARRV <var> ::= <id> [ <expr ] . <id>
    private STNode var()
    {
        STNode var, expr;
        SymbolEntry r = new SymbolEntry();
        r.setName(this.next.getLexeme());
        r.setLineNo(this.next.getLineNo());
        //Match & check for identifier token which is the start of the rule, <id>
        this.match(Tokens.TIDEN);
        //check for left bracket; <id> [
        if(this.next.getTokenID() == Tokens.TLBRK)
        {
            //match and consume lookahead
            this.match(Tokens.TLBRK);
            expr = this.expr();
            //match & check for ] in <expr> ]
            this.match(Tokens.TRBRK);
            //match and check for . which is after the ]
            this.match(Tokens.TDOTT);
            //match & check for identifier token, <id> at the end of the rule
            this.match(Tokens.TIDEN);
            //Rule has been satisifed completely so we set the node value of var to be NARRV
            //expr will be the left child of var
            var = new STNode(NodeValue.NARRV, expr);
            var.setRecord(r);
            return var;
        }
        //if we dont have the [ after <id> then we just have the NSIMV rule
        var = new STNode(NodeValue.NSIMV);
        var.setRecord(r);
        return var;
    }

    //Original Rule: NEXPL <elist> ::= <bool> , <elist> | <bool>
    //Left Factored: NEXPL <elist> ::= <bool> {epsilon | , <elist>}
    private STNode elist()
    {
        STNode bool, elist;
        bool = this.bool();
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //our lookahead is a coma so generate next valid token object from our scanner
            this.match(Tokens.TCOMA);
            //Recusive rule/function call
            elist = this.elist();
            //Return a node with the NodeValue NEXPL, bool as its left child and elist as its right child
            return new STNode(NodeValue.NEXPL, bool, elist);
        }
        //Epsilon path
        return bool;
    }

    //Original Rule:  NBOOL <bool> ::= <bool> <logop> <rel> | <rel>
    //Left Recursion: NBOOL <bool> ::= <rel> <booltail>
    //                      <booltail> ::= <logop> <rel> <booltail> | epsilon
    private STNode bool()
    {
        STNode b = this.rel();
        return this.booltail(b);
    }

    //Rule: <booltail> ::= <logop> <rel> <booltail> | epsilon
    private STNode booltail(STNode left)
    {
        STNode parent, right;
        SymbolEntry b = new SymbolEntry();
        //check for <logop>
        if(this.next.getTokenID() == Tokens.TTAND || this.next.getTokenID() == Tokens.TTTOR || this.next.getTokenID() == Tokens.TTXOR)
        {
            NodeValue nv = null;
            //AND
            if(this.next.getTokenID() == Tokens.TTAND) nv = NodeValue.NAND;
            //OR
            if(this.next.getTokenID() == Tokens.TTTOR) nv = NodeValue.NOR;
            //XOR
            if(this.next.getTokenID() == Tokens.TTXOR) nv = NodeValue.NXOR;
            //Assign the node value above to parent and set its left child to left
            parent = new STNode(nv,left);
            b.setType(this.next.getTokenID());
            parent.setRecord(b);
            //match and consume the lookahead
            this.match(this.next.getTokenID());
            //<rel>
            right = rel();
            //make the right child of parent be the node generated from the rule <rel>
            parent.setRightChild(right);
            //<booltail>
            return this.booltail(parent);
        }
        //Error check/recovery here?
        //epsilon path
        return left;
    }

    //Original Rule: NNOT    <rel>     ::= not <expr> <relop> <expr>
    //               Special <rel>     ::= <expr> <relop> <expr>
    //               Special <rel>     ::= <expr>
    //Left Factored: NNOT    <rel>     ::= not <expr> <relop> <expr>
    //               Special <rel>     ::= <expr> {epsilon | <relop> <expr>}
    private STNode rel()
    {
        //exprL is the left hand side <expr>
        //relop is for <relop>
        //exprR is the right hand side <expr>
        STNode exprL, relop, exprR;
        SymbolEntry r = new SymbolEntry();
        //if we have the not keyword
        if(this.next.getTokenID() == Tokens.TNOTT)
        {
            //assign the symbol entry type to be TNOTT
            r.setType(Tokens.TNOTT);
            //also manually add the not keyword to the attribute so we have the complete expression
            r.setName("not");
            //update the location of the symbol entry to be the location of the lookahead token in the source code file
            r.setLocation(this.next.getLineNo(), this.next.getColNo());
            //consume lookahead
            this.match(Tokens.TNOTT);
            exprL = this.expr();
            relop = this.relop();
            exprR = this.expr();
            STNode rel = new STNode(NodeValue.NNOT,exprL, relop, exprR);
            rel.setRecord(r);
            return rel;
        }
        exprL = this.expr();
        //check to see if we can satisfiy <relop> in <expr> <relop> <expr>
        if(this.next.getTokenID() == Tokens.TEQEQ || this.next.getTokenID() == Tokens.TNEQL ||
           this.next.getTokenID() == Tokens.TGRTR || this.next.getTokenID() == Tokens.TGEQL ||
           this.next.getTokenID() == Tokens.TLEQL || this.next.getTokenID() == Tokens.TLESS)
        {
            relop = this.relop();
            //We want the nodes generated by both <expr> rules in <expr> <relop> <expr> to be the left and right child of relop respectively
            relop.setLeftChild(exprL);
            exprR = this.expr();
            relop.setRightChild(exprR);
            return relop;
        }
        //return a node for <relop> ::= <expr>
        return exprL;
    }

    //Rules: NEQL <relop> ::= ==
    //       NNEQ <relop> ::= !=
    //       NGRT <relop> ::= >
    //       NGEQ <relop> ::= >=
    //       NLEQ <relop> ::= <=
    //       NLSS <relop> ::= <
    private STNode relop()
    {
        SymbolEntry r = new SymbolEntry();
        //update the location of the symbol entry to be the location of the lookahead token in the source code file
        r.setLocation(this.next.getLineNo(), this.next.getColNo());
        STNode relop = new STNode();
        switch(this.next.getTokenID())
        {
            //We assign relop a node value based on the lookahead
            //then we set the type of the SymbolEntry to be the token id of the lookahead
            //then we manually update the attribute of the SymbolEntry
            //assign that symbol entry to relop so it has a reference to it
            case TEQEQ:
                relop.setNodeValue(NodeValue.NEQL);
                r.setType(this.next.getTokenID());
                r.setName("==");
                relop.setRecord(r);
                break;
            case TNEQL:
                relop.setNodeValue(NodeValue.NNEQ);
                r.setType(this.next.getTokenID());
                r.setName("!=");
                relop.setRecord(r);
                break;
            case TGRTR:
                relop.setNodeValue(NodeValue.NGRT);
                r.setType(this.next.getTokenID());
                r.setName(">");
                relop.setRecord(r);
                break;
            case TGEQL:
                relop.setNodeValue(NodeValue.NGEQ);
                r.setType(this.next.getTokenID());
                r.setName(">=");
                relop.setRecord(r);
                break;
            case TLEQL:
                relop.setNodeValue(NodeValue.NLEQ);
                r.setType(this.next.getTokenID());
                r.setName("<=");
                relop.setRecord(r);
                break;
            case TLESS:
                relop.setNodeValue(NodeValue.NLSS);
                r.setType(this.next.getTokenID());
                r.setName("<");
                relop.setRecord(r);
                break;
        }
        //consume our lookahead token
        this.match(this.next.getTokenID());
        //Return relop
        return relop;
    }

    //Original Rule: NADD <expr> ::= <expr> + <term>
    //               NSUB <expr> ::= <expr> - <term>
    //Removed left recursion
    //Left Factored: NADD <expr> ::= <term> <exprtail>
    //               NSUB <expr> ::= <term> <exprtail>
    private STNode expr()
    {
        STNode term = this.term();
        //If we do not have a + or - then just <term> rule is returned
        return this.exprtail(term);
    }

    //Rule: <exprtail> ::= + <term> | - <term> | epsilon
    private STNode exprtail(STNode left)
    {
        STNode tail, term;
        SymbolEntry r = new SymbolEntry();
        //check for +
        if(this.next.getTokenID() == Tokens.TPLUS)
        {
            r.setType(Tokens.TPLUS);
            this.match(Tokens.TPLUS);
            term = this.term();
            //node value for NADD
            //left becomes the left child
            //term becomes the right child
            tail = new STNode(NodeValue.NADD, left, term);
            tail.setRecord(r);
            return tail;
        }
        //check for -
        if(this.next.getTokenID() == Tokens.TMINS)
        {
            r.setType(Tokens.TMINS);
            this.match(Tokens.TMINS);
            term = this.term();
            //node value for NSUB
            //left becomes the left child
            //term becomes the right child
            tail = new STNode(NodeValue.NSUB, left,  term);
            tail.setRecord(r);
            return tail;
        }
        //epsilon path
        return left;
    }

    //Combined all three rules into one function
    //Original Rules: NMUL <term> ::= <term> * <fact> | <fact>
    //                NDIV <term> ::= <term> / <fact> | <fact>
    //                NMOD <term> ::= <term> % <fact> | <fact>
    //Lef Factored:   NMUL <term> ::= <fact> {epsilon | * <term>}
    //                NDIV <term> ::= <fact> {epsilon | / <term>}
    //                NMOD <term> ::= <fact> {epsilon | % <term>}
    private STNode term()
    {
        STNode term, fact;
        SymbolEntry r = new SymbolEntry();
        fact = this.fact();
        if(this.next.getTokenID() == Tokens.TSTAR || this.next.getTokenID() == Tokens.TDIVD || this.next.getTokenID() == Tokens.TPERC)
        {
            //update the symbol entry
            r.setType(this.next.getTokenID());
            r.setLocation(this.next.getLineNo(), this.next.getColNo());
            STNode node = new STNode();
            //assign node a node value based on the lookahead token
            if(this.next.getTokenID() == Tokens.TSTAR) node.setNodeValue(NodeValue.NMUL);
            if(this.next.getTokenID() == Tokens.TDIVD) node.setNodeValue(NodeValue.NDIV);
            if(this.next.getTokenID() == Tokens.TPERC) node.setNodeValue(NodeValue.NMOD);
            //match & consume lookahead
            this.match(this.next.getTokenID());
            //satisfy <term> rule
            term = this.term();
            node.setLeftChild(term);
            node.setRightChild(fact);
            node.setRecord(r);
            return node;
        }
        //epsilon path in the left factored rules
        return fact;
    }

    // OR <exponent> came from <fact> ::= <exponent>
    //Original Rule: NPOW <fact> ::= <fact> ^ <exponent> | <exponent>
    //Left Factored: NPOW <fact> ::= <exponent> <facttail>
    private STNode fact()
    {
        STNode exp = this.exponent();
        return this.facttail(exp);
    }

    //Rule: <facttail> ::= ^ <exponent> <facttail> | epsilon
    private STNode facttail(STNode left)
    {
        STNode parent, right;
        SymbolEntry r = new SymbolEntry();
        if(this.next.getTokenID() == Tokens.TCART)
        {
            r.setType(Tokens.TCART);
            //match & consume our lookahead
            this.match(Tokens.TCART);
            parent = new STNode(NodeValue.NPOW, left);
            right = this.exponent();
            parent.setRightChild(right);
            parent.setRecord(r);
            return this.facttail(parent);
        }
        //epsilon path
        return left;
    }

    //Original Rules:
    //  NILIT   <exponent> ::= <intlit>
    //  NFLIT   <exponent> ::= <reallit>
    //  NTRUE   <exponent> ::= true
    //  NFALSE  <exponent> ::= false
    //  Special <exponent> ::= ( <bool> )
    //  Special <exponent> ::= <fncall>
    //  NFCALL  <fncall>   ::= <id> ( <elist> ) | <id> ( )
    //  Special <exponent> ::= <var>
    //  NSIMV   <var>      ::= <id>
    //  NARRV   <var>      ::= <id> [ <expr> ] . <id>
    private STNode exponent()
    {
        SymbolEntry r = new SymbolEntry();
        //Check for integer literal token
        if(this.next.getTokenID() == Tokens.TILIT)
        {
            r.setName(this.next.getLexeme());
            r.setType(Tokens.TINTG);
            this.match(Tokens.TILIT);
            return new STNode(NodeValue.NILIT, r);
        }
        //check for float literal token
        if(this.next.getTokenID() == Tokens.TFLIT)
        {
            //store the details of the float literal in a SymbolEntry object
            r.setName(this.next.getLexeme());
            r.setType(Tokens.TFLIT);
            //match & consume lookahead token
            this.match(Tokens.TFLIT);
            //return a node with NFLIT node value and r as its symbol record
            return new STNode(NodeValue.NFLIT, r);
        }
        //check for true keyword token
        if(this.next.getTokenID() == Tokens.TTRUE)
        {
            r.setType(Tokens.TTRUE);
            this.match(Tokens.TTRUE);
            return new STNode(NodeValue.NTRUE, r);
        }
        //check for false keyword token
        if(this.next.getTokenID() == Tokens.TFALS)
        {
            r.setType(Tokens.TFALS);
            this.match(Tokens.TFALS);
            return new STNode(NodeValue.NFALS, r);
        }
        //check for ( in the ( <bool> ) rule
        if(this.next.getTokenID() == Tokens.TLPAR)
        {
            //TODO add error checking
            this.match(Tokens.TLPAR);
            STNode b = this.bool();
            //check for ) in ( <bool> )
            this.match(Tokens.TRPAR);
            return b;
        }
        //check for start of <var> and <fncall>
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            STNode v = new STNode();
            //add the lexeme of the lookahead to the symbol record
            r.setName(this.next.getLexeme());
            r.setLocation(this.next.getLineNo(), this.next.getColNo());
            //match & consume our lookahead
            this.match(Tokens.TIDEN);
            //Since <exponent> ::= <var> comes before <exponent> ::= <fncall> I am making <var> take predence
            //NARRV <var> ::= <id> [ <expr> ] . <id>
            if(this.next.getTokenID() == Tokens.TLBRK)
            {
                v.setNodeValue(NodeValue.NARRV);
                //match & consume the lookahead token
                this.match(Tokens.TLBRK);
                STNode e = this.expr();
                //now match the ] and .
                this.match(Tokens.TRBRK);
                this.match(Tokens.TDOTT);
                //match the <id> at the end
                //TODO semantic check to ensure that this id matches with array declaration in globals
                this.match(Tokens.TIDEN);
                v.setRecord(r);
                //return the node generated by <expr> with a NARRV node as its left child
                e.setLeftChild(v);
                return e;
            }
            //now check for ( after <id> in <fncall>
            if(this.next.getTokenID() == Tokens.TLPAR)
            {
                STNode t = new STNode(NodeValue.NFCALL);
                //consume our lookahead
                this.match(Tokens.TLPAR);
                //check to see if we have <id> () in <fncalL>
                if(this.next.getTokenID() == Tokens.TRPAR)
                {
                    this.match(Tokens.TRPAR);
                    //r.setName("()");
                    t.setRecord(r);
                    return t;
                }
                //if we do not have <id> () then we must have <id> ( <elist> )
                STNode e = this.elist();
                t.setLeftChild(e);
                t.setRecord(r);
                //make the node generated by <elist> the left child of a new node with node valu NFCALL
                return t;
            }
            v.setNodeValue(NodeValue.NSIMV);
            v.setRecord(r);
            //if none of the above conditions are satisfied then we must have <var> ::= <id> so return a node with NSIMV as its node value
            return v;
        }
        return new STNode();
    }

    //Original Rule: NPRLST <prlist> ::= <printitem> , <prlist>
    //                      <prlist> ::= <printitem>
    //Left Factored: NPRLST <prlist> ::= <printitem> {epsilon | , <prlist>}
    private STNode prlist()
    {
        STNode item, list;
        item = this.printitem();
        //if we have a coma
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //generate next valid token
            this.match(Tokens.TCOMA);
            list = this.prlist();
            return new STNode(NodeValue.NPRLST, item, list);
        }
        //epsilon path
        return item;
    }

    //Rules: NSTRG   <printitem> ::= <string>
    //       Special <printitem> ::= <expr>
    private STNode printitem()
    {
        SymbolEntry r = new SymbolEntry();
        STNode print;
        if(this.next.getTokenID() == Tokens.TSTRG)
        {
            r.setName(this.next.getLexeme());
            r.setLocation(this.next.getLineNo(), this.next.getColNo());
            this.match(Tokens.TSTRG);
            print = new STNode(NodeValue.NSTRG);
            print.setRecord(r);
            return print;
        }
        return this.expr();
    }

    private boolean match(Tokens t)
    {
        if(this.next.getTokenID() == t)
        {
            this.nextToken();
            return true;
        }
        return false;
    }

    //Message style error reporting function
    private void errorSyntax(String s, int[] location)
    {
        String error = String.format("Syntax Error at line %d, col %d:  %s\n", location[0], location[1], s);
        this.getOutput().addSyntaxError(error);
    }

    private void errorSemantic(String s, int[] location)
    {
        String error = String.format("Semantic Error at line %d, col %d:  %s\n", location[0], location[1], s);
        this.getOutput().addSemanticError(error);
    }

    //Setters

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The root of the current object is assigned the STNode r
    public void setRoot(STNode r) {this.root = r;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The LexicalScanner object of the current object is assigned the value of ls
    public void setScanner(LexicalScanner ls) {this.scanner = ls;}

    //Normal setter for next
    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The next Token object of the current object is assigned the value of t
    public void setNext(Token t) {this.next = t;}

    //Secondary setter for next in which the LexicalScanner object of the SyntaxTree will generate the next valid token and assign it to next
    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: A new Token object is generated by the LexicalScanner object and assigned to the current objects next
    public void nextToken()
    {
        if(this.next.getTokenID() == null)
        {
            this.next = this.scanner.nextToken();
            return;
        }
        //While the scanner generates lexically invalid Token objects
        if (this.next.getTokenID() == Tokens.TUNDF)
        {
            do
            {
                //Send the invalid Token Object to the output controller so we can report the error
                this.output.addLexicalError(this.next);
                //Generate the next Token object from our scanner, if its valid then the loop will end
                this.next = this.scanner.nextToken();
            } while (this.next.getTokenID() == Tokens.TUNDF);
        }
        this.next = this.scanner.nextToken();
        //Since the lookahead token is lexically valid we can send it to the output controller
        this.output.addValidToken(this.next);
    }

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The OutputController object of the current SyntaxTree object that is used for errors is assigned the value of oc
    public void setOutput(OutputController oc) {this.output = oc;}

    //
    public void setTable(SymbolTable st) {this.table = st;}

    //Getters

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the root STNode of the current SyntaxTree object
    public STNode getRoot() {return this.root;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the LexicalScanner object of the current SyntaxTree object which is used for tokenizing
    public LexicalScanner getScanner() {return this.scanner;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the Token object which is being used as a look ahead after the grammar has been left factored into a LL(1) grammar
    public Token getNext() {return this.next;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the OutputController of the SyntaxTree that is being used for handling and displaying errors
    public OutputController getOutput() {return this.output;}

    public SymbolTable getTable() {return this.table;}
}
