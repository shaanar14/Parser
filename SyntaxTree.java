/*
    Project 2
    Author: Shaan Arora, C3236359
    SyntaxTree Class
    An abstract syntax tree data structure to represent the underlying structure of a CD20 program for future phases of compilation.
 */

//TODO add symbol table and error recovery logic
public class SyntaxTree
{
    //Private member variables

    //The root of the syntax tree
    private STNode root;
    //Lexical Scanner object so we can get the next lexeme
    private LexicalScanner scanner;
    //The next Token which is read by lookahead
    private Token next;
    //OutputController object for errors & listings
    private OutputController output;
    //Symbol Table object?

    //Default Constructor
    public SyntaxTree()
    {
        this.root = new STNode();
        this.scanner = new LexicalScanner();
        this.next = new Token();
        this.output = new OutputController();
    }

    //Only want this function to be public as this will just recursively generate the tree for us from the root node down
    //Dont want to return the root node because that exposes the entire tree
    public void generateTree()
    {
        //Generate the first valid token
        this.nextToken();
        //Recursively generate the Abstract Syntax Tree
        this.setRoot(this.program());
    }

    //Preconditions:  The current SyntaxTree object has been declared & intialized and generateTree() has been called
    //Postconditions: Display the AST in pre order notation in the terminal
    public void outputTree()
    {
        assert this.getRoot() != null : "generateTree() needs to be called";
        this.output.outputSyntaxTree(this);
    }

    //Output function for the internal LexicalScanner object
    //Preconditions:  Current SyntaxTree object has been declared & intialized and generateTree() has been called
    //Postconditions: Displays the Token objects generated by the LexicalScanner object to the terminal
    public void outputScanner()
    {
        assert this.getScanner().getStream().size() != 0 : "Please call generateTree()";
        this.output.outputLexicalScanner(this.getScanner());
    }

    //Recursive functions based on the CD20 grammar after it has been left factored and transformed into a LL(1) grammar
    //  Any rules in the grammar that have the node value Special do not create nodes but instead collapse up to the next rule which does have a node value
    //  Anything not wrapped in <> are specific keywords
    //  <id> , <structid> & <typeid> are all identifier Tokens generated by the scanner
    //  <ilit> , <reallit> & <string> are all special Tokens generated by the scanner

    //Preconditions:
    //Postconditions:
    //Rule: NPROG <program> ::= CD20 <id> <global> <funcs> <mainbody>
    private STNode program()
    {
        //NPROG
        STNode prog = new STNode(NodeValue.NPROG);
        if(this.next.getTokenID() == Tokens.TCD20)
        {
            //Make a new Symbol Entry object capturing the CD20 keyword
            SymbolEntry p = new SymbolEntry(Tokens.TCD20);
            //match & consume CD20 keyword token which should be at the start of every CD20 program in a source code file
            //this will return true because this.next is of Tokens CD20
            //  and also generate the next valid Token for our lookahead
            this.match(Tokens.TCD20);
            //check to see if we do have an identifier token after the CD20 keyword which is the program name
            if(this.next.getTokenID() == Tokens.TIDEN)
            {
                //Set the lexeme of our lookahead token to be the attribute of that SymbolEntry object that is capturing the CD20 keyword
                p.addToAttribute(this.next.getLexeme());
                //match & consume the identifier token
                //this will return true because our lookahead is of type TIDEN and will generate the next valid Token for our lookahead
                this.match(Tokens.TIDEN);
                //TODO SymbolTable.setProgram(p);
                //Now that we have successfuly generated a SymbolEntry for CD20 <id>
                //  we can now assign it as the record of the STNode prog above
                prog.setRecord(p);
            }
            else
            {
                this.error("Program name expected");
            }
        }
        else {this.error("CD20 keyword expected");}
        if(this.next.getTokenID() == Tokens.TCONS || this.next.getTokenID() == Tokens.TTYPS || this.next.getTokenID() == Tokens.TARRS)
        {
            //generate next valid token
            //not using match() because the start of <globals> will consume this.next
            this.nextToken();
            prog.setLeftChild(this.globals());
        }
        if (this.next.getTokenID() == Tokens.TFUNC)
        {
            prog.setMiddleChild(this.funcs());
        }
        prog.setRightChild(this.mainbody());
        return prog;
    }

    //Rules: NGLOB   <globals> ::= <consts> <types> <arrays>
    //       Special <consts>  ::= constants <initlist> | epsilon
    //       Special <types>   ::= types <typelist> | epsilon
    //       Special <arrays> ::=  arrays <arraydecls> | epsilon
    private STNode globals()
    {
        STNode consts = new STNode(), types = new STNode(), arrays = new STNode();
        //check if lookahead token is constants keyword
        if(this.next.getTokenID() == Tokens.TCNST)
        {
            //if we have the constants keyword then generate next valid token
            this.nextToken();
            //satisfy the rest of the <consts> rule
            consts = this.initlist();
        }
        //check if lookahead token is types keyword
        if(this.next.getTokenID() == Tokens.TCONS)
        {
            //generate next valid token
            this.nextToken();
            types = this.typelist();
        }
        if(this.next.getTokenID() == Tokens.TARRS)
        {
            this.nextToken();
            arrays = this.arraydecls();
        }
        //Return a STNode object with a NodeValue of NGLOB
        //  consts will be the left child but it could be an empty node because of epsilon path
        //  types will be the middle child but it could be an empty node because of epsilon path
        //  arrays will be the right child but it could be an empty because of epsilon path
        return new STNode(NodeValue.NGLOB, consts, types, arrays);
    }

    //Original Rule: NILIST <initlist> ::= <init> | <init> , <initlist>
    //Left Factored: NILIST <initlist> ::= <init> {epsilon | , <initlist>}
    private STNode initlist()
    {
        STNode tr1, tr2;
        //Only one <init> epsilon path
        tr1 = this.init();
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            this.nextToken();
            tr2 = this.initlist();
            return new STNode(NodeValue.NILIST, tr1, tr2);
        }
        return tr1;
    }

    //Rule: NINIT <init> ::= <id> = <expr>
    private STNode init()
    {
        //Consume <id> which will be an identifier Token object
        boolean consumed1 = this.match(Tokens.TIDEN);
        //Consume the equal symbol
        boolean consumed2 = this.match(Tokens.TEQUL);
        if(!consumed1)
        {
            if(!consumed2)
            {
                //If both match() return false then send error message
                this.error("Identifier and equal sign required");
            }
            //If we havent matched an identifier but we have seen an equal sign then error message
            this.error("Identifier required");
        }
        STNode expr = this.expr();
        return new STNode(NodeValue.NINIT, expr);
    }

    //Original Rule: NTYPEL <typelist> ::=  <type> <typelist> | <type>
    //Left Factored: NTYPEL <typelist> ::=  <type> {epsilon | <typelist>}
    private STNode typelist()
    {
        STNode t1, t2;
        t1 = this.type();
        //if we have the start of the <type> rule which is an identifier token
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            //dont want to generate next valid token because <type> will match and consume the identifier token
            t2 = this.typelist();
            return new STNode(NodeValue.NTYPEL, t1, t2);
        }
        //epsilon path
        return t1;
    }

    //Rules: NRTYPE <type> ::= <stuctid> is <fields> end
    //       NATYPE <type> ::= <typeid>  is arrrays [ <expr> ] of <structid>
    private STNode type()
    {
        //match identifier token, this is for both <structid> and <typeid> as they are both identifiers
        this.match(Tokens.TIDEN);
        //match is keyword
        this.match(Tokens.TTTIS);
        STNode type = new STNode();
        //for second rule where we have is arrays
        if(this.next.getTokenID() == Tokens.TARRS)
        {
            //if the token object is arrays then generate the next valid token object from the scanner
            this.nextToken();
            //match left square bracket
            this.match(Tokens.TLBRK);
            //Set the left child of type to be the STNode object returned by expr()
            type.setLeftChild(this.expr());
            //match right square bracket
            this.match(Tokens.TRBRK);
            //match of keyword
            this.match(Tokens.TTTOF);
            //match identifier token for <structid>
            this.match(Tokens.TIDEN);
            type.setNodeValue(NodeValue.NATYPE);
        }
        else
        {
            //if this.next is not arrays then we have the first rule
            type.setLeftChild(this.fields());
            this.match(Tokens.TTEND);
            type.setNodeValue(NodeValue.NRTYPE);
        }
        return type;
    }

    //Left Factored like initlist
    //Original Rule: NALIST <arrdecls> ::= <arrdecl> , <arrdecls> | <arrdecl>
    //Left Factored: NALIST <arrdecls> ::= <arrdecl> {epsilon | , <arrdecls>}
    private STNode arraydecls()
    {
        STNode a1, a2;
        a1 = arrdecl();
        //Check for coma
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            this.nextToken();
            a2 = arraydecls();
            //NALIST
            return new STNode(NodeValue.NALIST, a1, a2);
        }
        //Only one <arrdecl> present so epsilon path
        return a1;
    }

    //Rule: NARRD <arrdecl> ::= <id> : <typeid>
    private STNode arrdecl()
    {
        //match & consume identifier token for <id>
        boolean consumedID = this.match(Tokens.TIDEN);
        //match & consume identifier token for :
        boolean consumedColon = this.match(Tokens.TCOLN);
        //match & consume identifier token for <typeid>
        boolean consumedTID = this.match(Tokens.TIDEN);
        if(!consumedID)
        {
            if(!consumedColon)
            {
                if(!consumedTID)
                {
                    this.error("Identifier, colon and another identifier required");
                }
                this.error("Identifier and colon required");
            }
            this.error("Identifier required");
        }
        return new STNode(NodeValue.NARRD);
    }

    //Rule: NMAIN  <mainbody> ::= main <slist> begin <stats> end CD20 <id>
    private STNode mainbody()
    {
        //match main keyword
        this.match(Tokens.TMAIN);
        STNode slist = this.slist();
        //match begin keyword
        this.match(Tokens.TBEGN);
        STNode stats = this.stats();
        //match end keyword
        this.match(Tokens.TTEND);
        //match CD20 keyword
        this.match(Tokens.TCD20);
        //match identifier token for <id> which needs to also match the symbol table entry for the same identifier token for the very first CD20 token
        this.match(Tokens.TIDEN);
        //Return a STNode object with the NodeValue NMAIN, slist as its left child & stats as its right child
        return new STNode(NodeValue.NMAIN, slist, stats);
    }

    //Original Rule: NSDLST <slist> ::= epsilon | <sdecl> , <slist> | <sdecl>
    //Left Factored: NSDLST <slist> ::= <sdecl> {epsilon| , <slist>}
    private STNode slist()
    {
        STNode sdecl, slist;
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            this.match(Tokens.TIDEN);
            sdecl = this.sdecl();
            //check to see if we have a coma
            if(this.next.getTokenID() == Tokens.TCOMA)
            {
                //generate next valid token
                this.nextToken();
                slist = this.slist();
                return new STNode(NodeValue.NSDLST, sdecl, slist);
            }
        }
        //<slist> ::= epsilon
        return new STNode(NodeValue.NSDLST);
    }

    //Rule: NSDECL <sdecl> ::= <id> : int | <id> : real | <id> : bool
    //TODO change whats returned
    private STNode sdecl()
    {
        //match identifier token for <id>
        this.match(Tokens.TIDEN);
        //match colon token for :
        this.match(Tokens.TCOLN);
        //14 for int , 15 for real and 16 for bool
        if(this.next.getTokenID() == Tokens.TINTG || this.next.getTokenID() == Tokens.TREAL || this.next.getTokenID() == Tokens.TBOOL)
        {return new STNode(NodeValue.NSDECL);}
        this.error("int or real or bool keyword not found");
        return new STNode();
    }

    //Original Rule: NFLIST <fields> ::= <sdecl> , <fields> | <sdecl>
    //Left Factored: NFLIST <fields> ::= <sdecl> {epsilon | , <fields>}
    private STNode fields()
    {
        STNode f1, f2;
        f1 = this.sdecl();
        //check for coma for , <fields>
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //generate next valid token object from the scanner
            this.nextToken();
            f2 = this.fields();
            return new STNode(NodeValue.NFLIST, f1, f2);
        }
        //Epsilon path
        return f1;
    }

    //Original Rule: NFUNCS <funcs> ::= epsilon | <func> <funcs>  | <func>
    //Left Factored: NFUNCS <funcs> ::= epsilon | <func> {epsilon | <funcs>}
    private STNode funcs()
    {
        STNode func, funcs;
        //if we see another func keyword recursive call
        if(this.next.getTokenID() == Tokens.TFUNC)
        {
            //func() will match and consume the func keyword that we saw before we entered this function
            func = this.func();
            funcs = this.funcs();
            return new STNode(NodeValue.NFUNCS, func, funcs);
        }
        //<funcs> ::= epsilon path
        return new STNode(NodeValue.NFUNCS);
    }

    //Original Rule: NFUND   <func>     ::= func <id> ( <plist> ) : <rytpe> <funcbody>
    //               Special <plist>    ::= <params> | epsilon
    //               Special <rtype>    ::= <stype> | void
    //               Special <stype>    ::= int | real | bool
    //               Special <funcbody> ::= <locals> begin <stats> end
    //               Special <locals>   ::= <dlist> | epsilon
    //TODO change whats returned
    //TODO treat funcbody NMAIN?
    //rtype links up to symbol table
    private STNode func()
    {
        STNode params = new STNode(), dlist = new STNode(), stats;
        //match & consume func keyword
        //which will return true because the only way we can enter this function is the if statement in funcs()
        this.match(Tokens.TFUNC);
        //match identifier token for <id>
        this.match(Tokens.TIDEN);
        //match left parantheses token for (
        this.match(Tokens.TLPAR);
        //if we have the start of <params> which goes to <param> which starts with either <id> or const keyword
        //if we dont have the start of the <params> rule then thats okay because <plist> ::= epsilon
        if(this.next.getTokenID() == Tokens.TIDEN || this.next.getTokenID() == Tokens.TCONS) params = this.params();
        //match right parantheses token for )
        this.match(Tokens.TRPAR);
        //match colon token for :
        this.match(Tokens.TCOLN);
        //check for int or real or bool or void for <rtype>
        if(this.next.getTokenID() == Tokens.TVOID ||
           this.next.getTokenID() == Tokens.TINTG ||
           this.next.getTokenID() == Tokens.TREAL ||
           this.next.getTokenID() == Tokens.TBOOL)
        {
            //capture the keyword in a SymbolEntry
            //generate next valid token
            this.nextToken();
            //All this below is for <funcbody>
            //check for the start of the rule <dlist> which is an identifier token
            if(this.next.getTokenID() == Tokens.TIDEN) dlist = dlist();
            //match & consume begin keyword which will also generate the next valid token if successsful
            this.match(Tokens.TBEGN);
            stats = this.stats();
            //match & consume end keyword
            this.match(Tokens.TTEND);
            //Return a STNode object with the NodeValue NFUND
            //  params will be the left child but could be an empty node since  <plist>  ::= epsilon
            //  dlist will be the middle child but could be an empty node since <locals> ::= epsilon
            //  stats will be the right child which cannot be an empty node
            return new STNode(NodeValue.NFUND, params, dlist, stats);
        }
        this.error("int or real or bool or void not found");
        return new STNode();
    }

    //Original Rule: NPLIST  <params> ::= <param> , <params>
    //               Special <params> ::= <param>
    //Left Factored: NPLIST  <params> ::= <param> {epsilon | , <params>}
    private STNode params()
    {
        STNode param, params;
        param = this.param();
        //check to see if we have a coma for , <params>
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //generate next valid token
            this.nextToken();
            params = this.params();
            return new STNode(NodeValue.NPLIST, param, params);
        }
        //epsilon path
        return param;
    }

    //Rules: NSIMP <param> ::= <sdecl>
    //       NARRP <param> ::= <arrdecl>
    //       NARRC <param> ::= const <arrdecl>
    private STNode param()
    {
        SymbolEntry p = new SymbolEntry();
        STNode sdecl, arrdecl;
        //check for const keyword for the rule const <arrdecl>
        if(this.next.getTokenID() == Tokens.TCONS)
        {
            //this.next wont have a lexeme so add it manually
            p.addToAttribute("const");
            //match and consume our lookahead
            this.match(Tokens.TCONS);
            arrdecl = this.arrdecl();
            //Return a node for NodeValue NARCC with arrdecl as left child
            STNode t = new STNode(NodeValue.NARRC, arrdecl);
            t.setRecord(p);
            return t;
        }
        //check for <id> which is the start of both <sdecl> & <arrdecl>
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            p.addToAttribute(this.next.getLexeme());
            //match for identifier which is the start of both rules
            this.match(Tokens.TIDEN);
        }
        else {this.error("identifier expect");}
        //check for : after <id> in both <sdecl> & <arrdecl>
        if(this.next.getTokenID() == Tokens.TCOLN)
        {
            //since next is wont have a lexeme we just add the colon in manually
            p.addToAttribute(":");
            this.match(Tokens.TCOLN);
        }
        else {this.error("colon expected");}
        //if our lookahead is an identifier token then we can satisfy the  rule <arrdecl>
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            p.addToAttribute(this.next.getLexeme());
            //consume identifier
            this.match(Tokens.TIDEN);
            //<param> ::= <arrdecl>
            arrdecl = new STNode(NodeValue.NARRD);
            arrdecl.setRecord(p);
            return new STNode(NodeValue.NARRP, arrdecl);
        }
        //check for keyword after <id> in <sdecl>
        if(this.next.getTokenID() == Tokens.TINTG || this.next.getTokenID() == Tokens.TREAL || this.next.getTokenID() == Tokens.TBOOL)
        {
            //set the type of the SymbolEntry to be the keyword
            p.setType(this.next.getTokenID());
            //match and consume the keyword
            this.match(this.next.getTokenID());
            sdecl = new STNode(NodeValue.NSDECL);
            sdecl.setRecord(p);
            return new STNode(NodeValue.NSIMP, sdecl);
        }
        this.error("identifier or keyword expected");
        return new STNode();
    }

    //Original Rule: NDLIST  <dlist> ::= <decl> , <dlist>
    //               Special <dlist> ::= <decl>
    //               Special <decl>  ::= <sdecl> | <arrdecl>
    //Left Factored: NDLSIT  <dlist> ::= <sdecl> | <arrdecl> {epsilon | , <dlist>}
    private STNode dlist()
    {
        SymbolEntry r = new SymbolEntry();
        STNode decl = new STNode(), dlist;
        //<sdecl> & <arrdecl> both start with <id> so match & consume that
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            r.addToAttribute(this.next.getLexeme());
            this.match(Tokens.TIDEN);
        }
        else {this.error("identifier expect");}
        //check for : after <id> in both <sdecl> & <arrdecl>
        if(this.next.getTokenID() == Tokens.TCOLN)
        {
            //since next is wont have a lexeme we just add the colon in manually
            r.addToAttribute(":");
            this.match(Tokens.TCOLN);
        }
        //check for <sdecl>
        if(this.next.getTokenID() == Tokens.TINTG || this.next.getTokenID() == Tokens.TREAL || this.next.getTokenID() == Tokens.TBOOL)
        {
            //match & consume keyword
            this.match(this.next.getTokenID());
            decl = new STNode(NodeValue.NSDECL);
            decl.setRecord(r);
        }
        //check for <arrdecl>
        else if(this.next.getTokenID() == Tokens.TIDEN)
        {
            //add the lexeme of our lookahead token to our SymbolEntry
            r.addToAttribute(this.next.getLexeme());
            //match & consume our lookahead token
            this.match(Tokens.TIDEN);
            decl = new STNode(NodeValue.NARRD);
            decl.setRecord(r);
        }
        //check if lookahead is , if it is then we can satisfy , <dlist>
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //lookahead doesn't have a lexeme for TCOMA so add the comma to the record manually
            r.addToAttribute(",");
            //match & consume our lookahead
            this.match(Tokens.TCOMA);
            decl.setRecord(r);
            dlist = this.dlist();
            return new STNode(NodeValue.NDLIST, decl, dlist);
        }
        //epsilon path
        return decl;
    }

    //Original rules: NSTATS  <stats>   ::= <stat> ; <stats> | <strstat> <stats>
    //                Special <stats>   ::= <stat> ;  | <strstat>
    //                Special <strstat> ::= <forstat> | <ifstat>
    //                Special <stat>    ::= <repstat> | <asgnstat> | <iostat> | <callstat> | <returnstat>
    //Left Factored:  NSTATS  <stats>   ::= <stat> ;  | <strstat> {epsilon | <stats>}
    //TODO rework for <stats> ::= <stat> ; | <strstat>
    private STNode stats()
    {
        //stat1 for <stat> and stat2 for <strstat> and stats for recursive call
        STNode stat = new STNode(), str = new STNode(), stats;
        //deciding between <stat> ; and <strstat> based on if the lookahead token matches the start of these rules
        switch(this.next.getTokenID())
        {
            //case for <stat> ::= <repstat>
            //check if lookahead token is repeat keyword which is the start of <repstat>
            case TREPT:
                stat = this.repstat();
                //check for ; after <stat>
                this.match(Tokens.TSEMI);
                stats = this.stats();
                return new STNode(NodeValue.NSTATS, stat, stats);
            //case for <stat> ::= <iostat>
            //check if lookahead token is input or print or println keyword which is the start of <iostat>
            case TINPT, TPRIN, TPRLN:
                stat = this.iostat();
                //check for ; after <stat>
                this.match(Tokens.TSEMI);
                //recursive call/recursive rule
                stats = this.stats();
                return new STNode(NodeValue.NSTATS, stat, stats);
            //case 58 for <stat> ::= <asgnstat> | <callstat> which conflicts since they both start with <id>
            //technically <asgnstat> starts with <var> but <var> ::= <id>
            //case for <stat> ::= <returnstat>
            //check if lookahead token is return keyword which is the start of <returnstat>
            case TRETN:
                stat = this.returnstat();
                //match & consume ; after <stat>
                this.match(Tokens.TSEMI);
                stats = this.stats();
                return new STNode(NodeValue.NSTATS, stat, stats);
            //case for <strstat> ::= <forstat>
            //check if lookahead token is for keyword which is the start of <forstat>
            case TTFOR:
                str = this.forstat();
                stats = this.stats();
                return new STNode(NodeValue.NSTATS, str, stats);
            //case for <strstat> ::= <ifstat>
            //check if lookahead token is if keyword which is the start of <ifstat>
            case TIFTH:
                str = this.ifstat();
                stats = this.stats();
                return new STNode(NodeValue.NSTATS, str, stats);
            default: return new STNode(NodeValue.NSTATS, stat, str);
        }
    }

    //Rule: NFOR <forstat> ::= for ( <asgnlist> ; <bool> ) <stats> end
    private STNode forstat()
    {
        STNode alist, bool, stats;
        //match & consume for keyword
        this.match(Tokens.TTFOR);
        //match & consume left parentheses for (
        this.match(Tokens.TLPAR);
        //satisfy <asgnlist> rule
        alist = this.asgnlist();
        //match & consume comma
        this.match(Tokens.TCOMA);
        //satisfy <bool> rule
        bool = this.bool();
        //match & consume right parenthses for )
        this.match(Tokens.TRPAR);
        //satisfy <stats> rule
        stats = this.stats();
        //match & consume end keyword
        this.match(Tokens.TTEND);
        //Return a node for NodeValue NFOR, alist as left child, bool as middle child and stats as right child
        return new STNode(NodeValue.NFOR, alist, bool, stats);
    }

    //Rule: NREPT <repstat> ::= repeat ( <asgnlist> ) <stats> until <bool>
    private STNode repstat()
    {
        STNode alist, stats, bool;
        //match & consume repeat keyword
        this.match(Tokens.TREPT);
        //match & consume left parentheses for (
        this.match(Tokens.TLPAR);
        //satisfy <asgnlist> rule
        alist = this.asgnlist();
        //match & consume right parenthses for )
        this.match(Tokens.TRPAR);
        //satisfy <stats> rule
        stats = this.stats();
        //match & consume until keyword
        this.match(Tokens.TUNTL);
        //satisfy <bool> rule
        bool = this.bool();
        //return a node for NodeValue NREPT, alist becomes left child, stats becomes middle and bool becomes right
        return new STNode(NodeValue.NREPT, alist, stats, bool);
    }

    //Original Rule: NASGNS              <asgnlist> ::= <asgnstat> | <asgnstat>, <asgnlist>
    //               Special             <asgnstat> ::= <var> <asgnop> <bool>
    //               Multiple NodeValues <asgnop>   ::= = | += | -= | *= | /=
    //Left Factored: NASGNS              <asignlist> ::= <asgnstat> {epsilon | , <asgnlist>}
    //
    private STNode asgnlist()
    {
        //var for <var>, a for <asgnop>, bool for <bool>
        STNode var = new STNode(),
               a = new STNode(),
               bool = new STNode(),
        //stat for <asgnstat> and list for <asgnlist>
               stat ,list;
        //check for start of <asgnstat> rule which means to check for the start of <var>
        // which is <id>
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            //not generating next valid token because
            //var() will match and consume the lookahead which is an identifier token
            //capture node generated by <var>
            var = this.var();
            //capture node generated by <asgnop>
            a = this.asgnop();
            //capture node generated by <bool>
            bool = this.bool();
        }
        stat = new STNode(NodeValue.NASGNS, var, a, bool);
        //if we have a comma
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //generate next valid token
            this.nextToken();
            //capture node generated by recursive rule/call <asgnlist>
            list = this.asgnlist();
            //return a new node with NodeValue NASNS, stat is assigned as the left child and list becomes the right child
            return new STNode(NodeValue.NASGNS, stat, list);
        }
        //epsilon path in {epsilon | , <asgnlist>}
        return stat;
    }

    //Rules: NASGN <asgnop> ::= =
    //       NPLEQ <asgnop> ::= +=
    //       NMNEQ <asgnop> ::= -=
    //       NSTEQ <asgnop> ::= *=
    //       NDVEQ <asgnop> ::= /=
    //TODO refactor into switch statement
    private STNode asgnop()
    {
        STNode a = new STNode();
        //match & consume if we have a = for <asgnop> ::= =
        if(this.next.getTokenID() == Tokens.TEQUL)
        {
            this.match(Tokens.TEQUL);
            a.setNodeValue(NodeValue.NASGN);
        }
        //match & consume if we have a += for <asgnop> ::= +=
        if(this.next.getTokenID() == Tokens.TPLEQ)
        {
            this.match(Tokens.TPLEQ);
            a.setNodeValue(NodeValue.NPLEQ);
        }
        //match & consume if we have a -= for <asgnop> ::= -=
        if(this.next.getTokenID() == Tokens.TMNEQ)
        {
            this.match(Tokens.TMNEQ);
            a.setNodeValue(NodeValue.NMNEQ);
        }
        //match & consume if we have a *= for <asgnop> ::= *=
        if(this.next.getTokenID() == Tokens.TSTEQ)
        {
            this.match(Tokens.TSTEQ);
            a.setNodeValue(NodeValue.NSTEQ);
        }
        //match & consume if we have a /= for <asgnop> ::= /=
        if(this.next.getTokenID() == Tokens.TDVEQ)
        {
            this.match(Tokens.TDVEQ);
            a.setNodeValue(NodeValue.NDVEQ);
        }
        return a;
    }

    //This is the Dangling Else grammar which is a classic example of an ambigious grammar
    //Original Rule: NIFTH  <ifstat> ::= if ( <bool> ) <stats> end
    //               NIIFTE <ifstat> ::= if ( <bool> ) <stats> else <stats> end
    //Left Factored: <ifstat> ::= if ( <bool> ) <stats> <iftail>
    //               <iftail> ::= end | else <stats> end
    private STNode ifstat()
    {
        STNode bool, stats;
        //match & consume if keyword
        this.match(Tokens.TIFTH);
        //match & consume left parentheses for (
        this.match(Tokens.TLPAR);
        //generate node and satisfy <bool> rule
        bool = this.bool();
        //match & consume right parentheses for )
        this.match(Tokens.TRPAR);
        //generate node and satisfy <stats> rule
        stats = this.stats();
        return this.iftail(bool, stats);
    }

    //Rule: <iftail> ::= end | else <stats> end
    //TODO change whats returned
    private STNode iftail(STNode child1, STNode child2)
    {
        STNode iftail = new STNode();
        //if we have the end keyword
        if(this.next.getTokenID() == Tokens.TTEND)
        {
            //generate next valid token
            this.nextToken();
            iftail.setNodeValue(NodeValue.NIFTH);
            iftail.setLeftChild(child1);
            iftail.setRightChild(child2);
            return iftail;
        }
        //if we do not have the end keyword check for else keyword
        if(this.next.getTokenID() == Tokens.TELSE)
        {
            this.nextToken();
            STNode stats = stats();
            //generate a new node with NodeValue of NIFTE, child1 as left child, child2 as middle child and stats as right child
            iftail.setNodeValue(NodeValue.NIFTE);
            iftail.setLeftChild(child1);
            iftail.setMiddleChild(child2);
            iftail.setRightChild(stats);
            //match & consume end keyword
            this.match(Tokens.TTEND);
            return iftail;
        }
        //if all else fails an empty node is returned
        return iftail;
    }

    //Original Rule: NINPUT <iostat> ::= input   <vlist>
    //               NPRINT <iostat> ::= print   <prlist>
    //               NPRLN  <iostat> ::= println <prlist>
    //TODO change whats returned
    private STNode iostat()
    {
        STNode iostat = new STNode();
        //check for input keyword
        if(this.next.getTokenID() == Tokens.TINPT)
        {
            //generate next valid token
            this.nextToken();
            STNode vlist = this.vlist();
            iostat.setNodeValue(NodeValue.NINPUT);
            iostat.setLeftChild(vlist);
            //return a new node with NINPUT as its node value and vlist as its left child
            return iostat;
        }
        //check for print or println keyword
        if(this.next.getTokenID() == Tokens.TPRIN || this.next.getTokenID() == Tokens.TPRLN)
        {
            //if we have the print keyword then the NodeValue for iostat is NPRINT
            if(this.next.getTokenID() == Tokens.TPRIN) iostat.setNodeValue(NodeValue.NPRINT);
            //same as above but for println keyword
            if(this.next.getTokenID() == Tokens.TPRLN) iostat.setNodeValue(NodeValue.NPRLN);
            STNode prlist = this.prlist();
            iostat.setLeftChild(prlist);
            return iostat;
        }
        //if none of the keywords are there an empty node is returned
        return iostat;
    }

    //Original Rule: NCALL <callstat> ::= <id> ( <elist> ) | <id> ()
    private STNode callstat()
    {
        //match & consume identifier token for <id>
        this.match(Tokens.TIDEN);
        //match & consume left parantheses token for (
        this.match(Tokens.TLPAR);
        //if we just have <id> () then return NCALL node
        if(this.next.getTokenID() == Tokens.TRPAR)
        {
            //match & consume right parentheses for )
            this.match(Tokens.TRPAR);
            return new STNode(NodeValue.NCALL);
        }
        //if we have don't have <id> () we must have <id> ( <elist> )
        //create a new node for <elist>
        STNode elist = this.elist();
        //match & consume right parentheses for )
        this.match(Tokens.TRPAR);
        //make elist the left child of the new NCALL node
        return new STNode(NodeValue.NCALL, elist);
    }

    //Rule: NRETN <returnstat> ::= return | return <expr>
    private STNode returnstat()
    {
        //match and consume return keyword
        this.match(Tokens.TRETN);
        //if we have a semicolon after the return keyword <stat> will consume it
        if(this.next.getTokenID() == Tokens.TRETN) return new STNode(NodeValue.NRETN);
        STNode expr = this.expr();
        //Return a node with the NRETN NodeValue and expr as its left child
        return new STNode(NodeValue.NRETN, expr);
    }

    //Original Rule: NVLIST <vlist> ::= <var> , <vlist> | <var>
    //Left Factored: NVLIST <vlist> ::= <var> {epsilon | , <vlist>}
    private STNode vlist()
    {
        STNode vlist, var;
        var = this.var();
        //if the look ahead token is a coma then we can consume it and make a recusive call for <vlist>
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //generate next valid token
            this.nextToken();
            vlist = this.vlist();
            //var which is <var> will be the left child and vlist which is <vlist> will be the right child
            return new STNode(NodeValue.NVLIST, var, vlist);
        }
        return var;
    }

    //Original Rules: NSIMV <var> ::= <id>
    //                NARRV <var> ::= <id> [ <expr ] . <id>
    private STNode var()
    {
        STNode var, expr;
        //Match & check for identifier token which is the start of the rule, <id>
        this.match(Tokens.TIDEN);
        //check for left bracket; <id> [
        if(this.next.getTokenID() == Tokens.TLBRK)
        {
            //generate the next valid token
            this.nextToken();
            expr = this.expr();
            //match & check for ] in <expr> ]
            this.match(Tokens.TRBRK);
            //match and check for . which is after the ]
            this.match(Tokens.TDOTT);
            //match & check for identifier token, <id> at the end of the rule
            this.match(Tokens.TIDEN);
            //Rule has been satisifed completely so we set the node value of var to be NARRV
            //expr will be the left child of var
            var = new STNode(NodeValue.NARRV, expr);
            return var;
        }
        //if we dont have the [ after <id> then we just have the NSIMV rule
        var = new STNode(NodeValue.NSIMV);
        return var;
    }

    //Original Rule: NEXPL <elist> ::= <bool> , <elist> | <bool>
    //Left Factored: NEXPL <elist> ::= <bool> {epsilon | , <elist>}
    private STNode elist()
    {
        STNode bool, elist;
        bool = this.bool();
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //our lookahead is a coma so generate next valid token object from our scanner
            this.nextToken();
            //Recusive rule/function call
            elist = this.elist();
            //Return a node with the NodeValue NEXPL, bool as its left child and elist as its right child
            return new STNode(NodeValue.NEXPL, bool, elist);
        }
        //Epsilon path
        return bool;
    }

    //Original Rule:  NBOOL <bool> ::= <bool> <logop> <rel> | <rel>
    //Left Recursion: NBOOL <bool> ::= <rel> <booltail>
    //                      <booltail> ::= <logop> <rel> <booltail> | epsilon
    private STNode bool()
    {
        //new node for NBOOL
        STNode bool = new STNode(NodeValue.NBOOL);
        //node to capture <rel>
        STNode rel = this.rel();
        //node to capture <booltail> which can be epsilon
        STNode tail = this.booltail(rel);
        bool.setLeftChild(tail);
        //return NBOOL ndode
        return bool;
    }

    //Rule: <booltail> ::= <logop> <rel> <booltail> | epsilon
    private STNode booltail(STNode left)
    {
        STNode parent, right;
        //If we have <logop> then try to satisfy the <rel> <booltail> part of the rule
        if(this.next.getTokenID() == Tokens.TTAND || this.next.getTokenID() == Tokens.TTTOR || this.next.getTokenID() == Tokens.TTXOR)
        {
            NodeValue nv = null;
            //AND
            if(this.next.getTokenID() == Tokens.TTAND) nv = NodeValue.NAND;
            //OR
            if(this.next.getTokenID() == Tokens.TTTOR) nv = NodeValue.NOR;
            //XOR
            if(this.next.getTokenID() == Tokens.TTXOR) nv = NodeValue.NXOR;
            //Assign the node value above to parent and set its left child to left
            parent = new STNode(nv,left);
            //Generate next valid Token object from the scanner
            this.nextToken();
            //<rel>
            right = rel();
            parent.setRightChild(right);
            //<booltail>
            return this.booltail(parent);
        }
        //Error check/recovery here?
        //epsilon path
        return left;
    }

    //Original Rule: NNOT    <rel> ::= not <expr> <relop> <expr>
    //               Special <rel> ::= <expr> <relop> <expr>
    //               Special <rel> ::= <expr>
    //TODO left factor to have <reltail>
    // rel -> expr reltail
    // reltail -> epsilon | relop expr
    private STNode rel()
    {
        STNode exprL, relop, exprR;
        //if we have the not keyword
        if(this.next.getTokenID() == Tokens.TNOTT)
        {
            exprL = this.expr();
            relop = this.relop();
            exprR = this.expr();
            return new STNode(NodeValue.NNOT, exprL, relop, exprR);
        }
        return this.expr();
    }

    //Rules: NEQL <relop> ::= ==
    //       NNEQ <relop> ::= !=
    //       NGRT <relop> ::= >
    //       NGEQ <relop> ::= >=
    //       NLEQ <relop> ::= <=
    //       NLSS <relop> ::= <
    private STNode relop()
    {
        return switch(this.next.getTokenID())
        {
            case TEQEQ -> new STNode(NodeValue.NEQL);
            case TNEQL -> new STNode(NodeValue.NNEQ);
            case TGRTR -> new STNode(NodeValue.NGRT);
            case TGEQL -> new STNode(NodeValue.NGEQ);
            case TLEQL -> new STNode(NodeValue.NLEQ);
            case TLESS -> new STNode(NodeValue.NLSS);
            default -> new STNode();
        };
    }

    //Original Rule: NADD <expr> ::= <expr> + <term>
    //               NSUB <expr> ::= <expr> - <term>
    //Left Factored: NADD <expr> ::= <term> <exprtail>
    //               NSUB <expr> ::= <term> <exprtail>
    private STNode expr()
    {
        STNode term = this.term();
        //If we do not have a + or - then just <term> rule is returned
        return this.exprtail(term);
    }

    //Rule: <exprtail> ::= + <term> | - <term> | epsilon
    private STNode exprtail(STNode left)
    {
        STNode tail, term;
        //check for +
        if(this.next.getTokenID() == Tokens.TPLUS)
        {
            this.nextToken();
            term = this.term();
            //node value for NADD
            //term becomes the left child
            tail = new STNode(NodeValue.NADD, term);
            return tail;
        }
        //check for -
        if(this.next.getTokenID() == Tokens.TMINS)
        {
            this.nextToken();
            term = this.term();
            //node value for NADD
            //term becomes the left child
            tail = new STNode(NodeValue.NSUB, term);
            return tail;
        }
        //epsilon path
        return left;
    }

    //Combined all three rules into one function
    //Original Rules: NMUL <term> ::= <term> * <fact> | <fact>
    //                NDIV <term> ::= <term> / <fact> | <fact>
    //                NMOD <term> ::= <term> % <fact> | <fact>
    //Lef Factored:   NMUL <term> ::= <fact> {epsilon | * <term>}
    //                NDIV <term> ::= <fact> {epsilon | / <term>}
    //                NMOD <term> ::= <fact> {epsilon | % <term>}
    private STNode term()
    {
        STNode term, fact;
        fact = this.fact();
        if(this.next.getTokenID() == Tokens.TSTAR || this.next.getTokenID() == Tokens.TDIVD || this.next.getTokenID() == Tokens.TPERC)
        {
            //generate next valid token
            this.nextToken();
            term = this.term();
            if(this.next.getTokenID() == Tokens.TSTAR) return new STNode(NodeValue.NMUL, term, fact);
            if(this.next.getTokenID() == Tokens.TDIVD) return new STNode(NodeValue.NDIV, term, fact);
            if(this.next.getTokenID() == Tokens.TPERC) return new STNode(NodeValue.NMOD, term, fact);
        }
        //epsilon path in the left factored rules
        return fact;
    }

    // OR <exponent> came from <fact> ::= <exponent>
    //Original Rule: NPOW <fact> ::= <fact> ^ <exponent> | <exponent>
    //Left Factored: NPOW <fact> ::= <exponent> <facttail>
    private STNode fact()
    {
        STNode exp = this.exponent();
        return this.facttail(exp);
    }

    //Rule: <facttail> ::= ^ <exponent> <facttail> | epsilon
    private STNode facttail(STNode left)
    {
        STNode parent, right;
        if(this.next.getTokenID() == Tokens.TCART)
        {
            //we have found the ^ so generate the next valid token
            this.nextToken();
            parent = new STNode(NodeValue.NPOW, left);
            right = this.exponent();
            parent.setRightChild(right);
            return this.facttail(parent);
        }
        //epsilon path
        return left;
    }

    //Original Rules:
    //  <exponent> ::= <intlit>
    //  <exponent> ::= <reallit>
    //  <exponent> ::= true
    //  <exponent> ::= false
    //  <exponent> ::= ( <bool> )
    //  <exponent> ::= <fncall>
    //  <exponent> ::= <var>
    private STNode exponent()
    {
        //Check for integer literal token
        if(this.next.getTokenID() == Tokens.TILIT) return new STNode(NodeValue.NILIT);
        //check for float literal token
        if(this.next.getTokenID() == Tokens.TFLIT) return new STNode(NodeValue.NFLIT);
        //check for true keyword token
        if(this.next.getTokenID() == Tokens.TTRUE) return new STNode(NodeValue.NTRUE);
        //check for false keyword token
        if(this.next.getTokenID() == Tokens.TFALS) return new STNode(NodeValue.NFALS);
        //check for ( in the ( <bool> ) rule
        if(this.next.getTokenID() == Tokens.TLPAR)
        {
            this.nextToken();
            return this.bool();
        }
        //check for identifier which is the start of the <fncall> rule
        if(this.next.getTokenID() == Tokens.TIDEN)
        {
            this.nextToken();
            return this.fncall();
        }
        //if all rules above are not satisfied then satisiy the <var> rule
        return this.var();
    }

    //Original Rule: NFCALL <fncall> ::= <id> ( <elist> ) | <id> ()
    //TODO need to make <elist> optional, this rule is similar to <callstat>
    private STNode fncall()
    {
        STNode elist;
        //match & consume identifier token for <id>
        this.match(Tokens.TIDEN);
        //match & consume left parentheses token for (
        this.match(Tokens.TLPAR);
        //generate node and satisfy <elist> rule
        elist = this.elist();
        //match & consume right paranetheses token for )
        this.match(Tokens.TRPAR);
        return new STNode(NodeValue.NFCALL, elist);
    }

    //Original Rule: NPRLST <prlist> ::= <printitem> , <prlist>
    //                      <prlist> ::= <printitem>
    //Left Factored: NPRLST <prlist> ::= <printitem> {epsilon | , <prlist>}
    private STNode prlist()
    {
        STNode item, list;
        item = this.printitem();
        //if we have a coma
        if(this.next.getTokenID() == Tokens.TCOMA)
        {
            //generate next valid token
            this.nextToken();
            list = this.prlist();
            return new STNode(NodeValue.NPRLST, item, list);
        }
        //epsilon path
        return item;
    }

    //Rules: NSTRG   <printitem> ::= <string>
    //       Special <printitem> ::= <expr>
    private STNode printitem()
    {
        //check if the lookahead token is a string literal, if so return a node for NodeValue NSTRG
        //otherwise just return the node created by <expr>
        return this.next.getTokenID() == Tokens.TSTRG ? new STNode(NodeValue.NSTRG) : this.expr();
    }

    private boolean match(Tokens t)
    {
        if(this.next.getTokenID() == t)
        {
            this.nextToken();
            return true;
        }
        else
        {
            this.error(this.next);
            return false;
        }
    }

    //Message style error reporting function
    private void error(String s)
    {
        String e = "Syntax Error: " + s;
        this.getOutput().addSyntaxError(e);
    }

    //Token based error reporting function
    private void error(Token t)
    {
        String e = String.format("Line %d, Column %d: %s\n", t.getLineNo(), t.getColNo(), t.getLexeme());
        this.getOutput().addSyntaxError(e);
    }

    //Setters

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The root of the current object is assigned the STNode r
    public void setRoot(STNode r) {this.root = r;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The LexicalScanner object of the current object is assigned the value of ls
    public void setScanner(LexicalScanner ls) {this.scanner = ls;}

    //Normal setter for next
    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The next Token object of the current object is assigned the value of t
    public void setNext(Token t) {this.next = t;}

    //Secondary setter for next in which the LexicalScanner object of the SyntaxTree will generate the next valid token and assign it to next
    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: A new Token object is generated by the LexicalScanner object and assigned to the current objects next
    public void nextToken()
    {
        //While the scanner generates lexically invalid Token objects
        while(this.next.getTokenID() == Tokens.TUNDF)
        {
            //Send the invalid Token Object to the output controller so we can report the error
            this.output.addLexicalError(this.next);
            //Generate the next Token object from our scanner, if its valid then the loop will end
            this.next = this.scanner.nextToken();
        }
        //Since next does not have an ID of 62 then its a lexically valid Token object so send it to the OutputController
        this.output.addValidToken(this.next);
    }

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: The OutputController object of the current SyntaxTree object that is used for errors is assigned the value of oc
    public void setOutput(OutputController oc) {this.output = oc;}

    //Getters

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the root STNode of the current SyntaxTree object
    public STNode getRoot() {return this.root;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the LexicalScanner object of the current SyntaxTree object which is used for tokenizing
    public LexicalScanner getScanner() {return this.scanner;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the Token object which is being used as a look ahead after the grammar has been left factored into a LL(1) grammar
    public Token getNext() {return this.next;}

    //Preconditions: SyntaxTree object has been declared and initialized
    //Postconditions: Returns the OutputController of the SyntaxTree that is being used for handling and displaying errors
    public OutputController getOutput() {return this.output;}
}
